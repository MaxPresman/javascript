{"version":3,"sources":["node_modules/browser-pack/_prelude.js","lib/main.js","pubnub.js","package.json"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","_package","version","../package.json",2,"name","description","main","scripts","test","author","license","devDependencies","babel-preset-es2015","browserify","gulp","gulp-babel","gulp-rename","gulp-sourcemaps","gulp-uglify","gulp-util","run-sequence","vinyl-buffer","vinyl-source-stream","dependencies","underscore"],"mappings":"CAAA,QAAAA,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,GAAA,kBAAAC,UAAAA,OAAA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAI,EAAA,MAAAA,GAAAJ,GAAA,EAAA,IAAAK,GAAA,GAAAC,OAAA,uBAAAN,EAAA,IAAA,MAAAK,GAAAE,KAAA,mBAAAF,EAAA,GAAAG,GAAAX,EAAAG,IAAAS,WAAAb,GAAAI,GAAA,GAAAU,KAAAF,EAAAC,QAAA,SAAAd,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,EAAAA,EAAAF,IAAAa,EAAAA,EAAAC,QAAAd,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAS,QAAA,IAAA,GAAAL,GAAA,kBAAAD,UAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAAa,OAAAX,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAa,GAAA,SAAAT,EAAAU,EAAAJ,GCAA,YAEA,IAAAK,GAAAX,EAAA,kBAiBAW,GAAAC,UCwyDGC,kBAAkB,IAAIC,GAAG,SAASd,EAAQU,EAAOJ,GC3zDpDI,EAAAJ,SACAS,KAAA,gBACAH,QAAA,QACAI,YAAA,GACAC,KAAA,WACAC,SACAC,KAAA,6CAEAC,OAAA,GACAC,QAAA,MACAC,iBACAC,sBAAA,UACAC,WAAA,UACAC,KAAA,SACAC,aAAA,SACAC,cAAA,SACAC,kBAAA,SACAC,cAAA,SACAC,YAAA,SACAC,eAAA,SACAC,eAAA,SACAC,sBAAA,UAEAC,cACAC,WAAA,qBDg0DW","file":"pubnub.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar _package = require('../package.json');\n\nfunction _typeof(obj) { return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }\n\nvar NOW = 1;\nvar READY = false;\nvar READY_BUFFER = [];\nvar PRESENCE_SUFFIX = '-pnpres';\nvar DEF_WINDOWING = 10; // MILLISECONDS.\nvar DEF_TIMEOUT = 10000; // MILLISECONDS.\nvar DEF_SUB_TIMEOUT = 310; // SECONDS.\nvar DEF_KEEPALIVE = 60; // SECONDS (FOR TIMESYNC).\nvar SECOND = 1000; // A THOUSAND MILLISECONDS.\nvar URLBIT = '/';\nvar PARAMSBIT = '&';\nvar PRESENCE_HB_THRESHOLD = 5;\nvar PRESENCE_HB_DEFAULT = 30;\nvar SDK_VER = _package.version;\nvar REPL = /{([\\w\\-]+)}/g;\n\n/**\n * Generate Subscription Channel List\n * ==================================\n * generate_channel_list(channels_object);\n */\nfunction generate_channel_list(channels, nopresence) {\n    var list = [];\n    each(channels, function (channel, status) {\n        if (nopresence) {\n            if (channel.search('-pnpres') < 0) {\n                if (status.subscribed) list.push(channel);\n            }\n        } else {\n            if (status.subscribed) list.push(channel);\n        }\n    });\n    return list.sort();\n}\n\n/**\n * Generate Subscription Channel Groups List\n * ==================================\n * generate_channel_group_list(channels_groups object);\n */\nfunction generate_channel_group_list(channel_groups, nopresence) {\n    var list = [];\n    each(channel_groups, function (channel_group, status) {\n        if (nopresence) {\n            if (channel_group.search('-pnpres') < 0) {\n                if (status.subscribed) list.push(channel_group);\n            }\n        } else {\n            if (status.subscribed) list.push(channel_group);\n        }\n    });\n    return list.sort();\n}\n\n// PUBNUB READY TO CONNECT\nfunction ready() {\n    timeout(function () {\n        if (READY) return;\n        READY = 1;\n        each(READY_BUFFER, function (connect) {\n            connect();\n        });\n    }, SECOND);\n}\n\nfunction PNmessage(args) {\n    msg = args || { 'apns': {} }, msg['getPubnubMessage'] = function () {\n        var m = {};\n\n        if (Object.keys(msg['apns']).length) {\n            m['pn_apns'] = {\n                'aps': {\n                    'alert': msg['apns']['alert'],\n                    'badge': msg['apns']['badge']\n                }\n            };\n            for (var k in msg['apns']) {\n                m['pn_apns'][k] = msg['apns'][k];\n            }\n            var exclude1 = ['badge', 'alert'];\n            for (var k in exclude1) {\n                delete m['pn_apns'][exclude1[k]];\n            }\n        }\n\n        if (msg['gcm']) {\n            m['pn_gcm'] = {\n                'data': msg['gcm']\n            };\n        }\n\n        for (var k in msg) {\n            m[k] = msg[k];\n        }\n        var exclude = ['apns', 'gcm', 'publish', 'channel', 'callback', 'error'];\n        for (var k in exclude) {\n            delete m[exclude[k]];\n        }\n\n        return m;\n    };\n    msg['publish'] = function () {\n\n        var m = msg.getPubnubMessage();\n\n        if (msg['pubnub'] && msg['channel']) {\n            msg['pubnub'].publish({\n                'message': m,\n                'channel': msg['channel'],\n                'callback': msg['callback'],\n                'error': msg['error']\n            });\n        }\n    };\n    return msg;\n}\n\nfunction PN_API(setup) {\n    var SUB_WINDOWING = +setup['windowing'] || DEF_WINDOWING,\n        SUB_TIMEOUT = (+setup['timeout'] || DEF_SUB_TIMEOUT) * SECOND,\n        KEEPALIVE = (+setup['keepalive'] || DEF_KEEPALIVE) * SECOND,\n        TIME_CHECK = setup['timecheck'] || 0,\n        NOLEAVE = setup['noleave'] || 0,\n        PUBLISH_KEY = setup['publish_key'],\n        SUBSCRIBE_KEY = setup['subscribe_key'],\n        AUTH_KEY = setup['auth_key'] || '',\n        SECRET_KEY = setup['secret_key'] || '',\n        hmac_SHA256 = setup['hmac_SHA256'],\n        SSL = setup['ssl'] ? 's' : '',\n        ORIGIN = 'http' + SSL + '://' + (setup['origin'] || 'pubsub.pubnub.com'),\n        STD_ORIGIN = nextorigin(ORIGIN),\n        SUB_ORIGIN = nextorigin(ORIGIN),\n        CONNECT = function CONNECT() {},\n        PUB_QUEUE = [],\n        CLOAK = true,\n        TIME_DRIFT = 0,\n        SUB_CALLBACK = 0,\n        SUB_CHANNEL = 0,\n        SUB_RECEIVER = 0,\n        SUB_RESTORE = setup['restore'] || 0,\n        SUB_BUFF_WAIT = 0,\n        TIMETOKEN = 0,\n        RESUMED = false,\n        CHANNELS = {},\n        CHANNEL_GROUPS = {},\n        SUB_ERROR = function SUB_ERROR() {},\n        STATE = {},\n        PRESENCE_HB_TIMEOUT = null,\n        PRESENCE_HB = validate_presence_heartbeat(setup['heartbeat'] || setup['pnexpires'] || 0, setup['error']),\n        PRESENCE_HB_INTERVAL = setup['heartbeat_interval'] || PRESENCE_HB / 2 - 1,\n        PRESENCE_HB_RUNNING = false,\n        NO_WAIT_FOR_PENDING = setup['no_wait_for_pending'],\n        COMPATIBLE_35 = setup['compatible_3.5'] || false,\n        xdr = setup['xdr'],\n        params = setup['params'] || {},\n        _error = setup['error'] || function () {},\n        _is_online = setup['_is_online'] || function () {\n        return 1;\n    },\n        jsonp_cb = setup['jsonp_cb'] || function () {\n        return 0;\n    },\n        db = setup['db'] || { 'get': function get() {}, 'set': function set() {} },\n        CIPHER_KEY = setup['cipher_key'],\n        UUID = setup['uuid'] || !setup['unique_uuid'] && db && db['get'](SUBSCRIBE_KEY + 'uuid') || '',\n        USE_INSTANCEID = setup['instance_id'] || false,\n        INSTANCEID = '',\n        _shutdown = setup['shutdown'],\n        use_send_beacon = typeof setup['use_send_beacon'] != 'undefined' ? setup['use_send_beacon'] : true,\n        sendBeacon = use_send_beacon ? setup['sendBeacon'] : null,\n        _poll_timer,\n        _poll_timer2;\n\n    if (PRESENCE_HB === 2) PRESENCE_HB_INTERVAL = 1;\n\n    var crypto_obj = setup['crypto_obj'] || {\n        'encrypt': function encrypt(a, key) {\n            return a;\n        },\n        'decrypt': function decrypt(b, key) {\n            return b;\n        }\n    };\n\n    function _get_url_params(data) {\n        if (!data) data = {};\n        each(params, function (key, value) {\n            if (!(key in data)) data[key] = value;\n        });\n        return data;\n    }\n\n    function _object_to_key_list(o) {\n        var l = [];\n        each(o, function (key, value) {\n            l.push(key);\n        });\n        return l;\n    }\n    function _object_to_key_list_sorted(o) {\n        return _object_to_key_list(o).sort();\n    }\n\n    function _get_pam_sign_input_from_params(params) {\n        var si = \"\";\n        var l = _object_to_key_list_sorted(params);\n\n        for (var i in l) {\n            var k = l[i];\n            si += k + \"=\" + pam_encode(params[k]);\n            if (i != l.length - 1) si += \"&\";\n        }\n        return si;\n    }\n\n    function validate_presence_heartbeat(heartbeat, cur_heartbeat, error) {\n        var err = false;\n\n        if (typeof heartbeat === 'undefined') {\n            return cur_heartbeat;\n        }\n\n        if (typeof heartbeat === 'number') {\n            if (heartbeat > PRESENCE_HB_THRESHOLD || heartbeat == 0) err = false;else err = true;\n        } else if (typeof heartbeat === 'boolean') {\n            if (!heartbeat) {\n                return 0;\n            } else {\n                return PRESENCE_HB_DEFAULT;\n            }\n        } else {\n            err = true;\n        }\n\n        if (err) {\n            error && error(\"Presence Heartbeat value invalid. Valid range ( x > \" + PRESENCE_HB_THRESHOLD + \" or x = 0). Current Value : \" + (cur_heartbeat || PRESENCE_HB_THRESHOLD));\n            return cur_heartbeat || PRESENCE_HB_THRESHOLD;\n        } else return heartbeat;\n    }\n\n    function encrypt(input, key) {\n        return crypto_obj['encrypt'](input, key || CIPHER_KEY) || input;\n    }\n    function decrypt(input, key) {\n        return crypto_obj['decrypt'](input, key || CIPHER_KEY) || crypto_obj['decrypt'](input, CIPHER_KEY) || input;\n    }\n\n    function error_common(message, callback) {\n        callback && callback({ 'error': message || \"error occurred\" });\n        _error && _error(message);\n    }\n    function _presence_heartbeat() {\n\n        clearTimeout(PRESENCE_HB_TIMEOUT);\n\n        if (!PRESENCE_HB_INTERVAL || PRESENCE_HB_INTERVAL >= 500 || PRESENCE_HB_INTERVAL < 1 || !generate_channel_list(CHANNELS, true).length && !generate_channel_group_list(CHANNEL_GROUPS, true).length) {\n            PRESENCE_HB_RUNNING = false;\n            return;\n        }\n\n        PRESENCE_HB_RUNNING = true;\n        SELF['presence_heartbeat']({\n            'callback': function callback(r) {\n                PRESENCE_HB_TIMEOUT = timeout(_presence_heartbeat, PRESENCE_HB_INTERVAL * SECOND);\n            },\n            'error': function error(e) {\n                _error && _error(\"Presence Heartbeat unable to reach Pubnub servers.\" + JSON.stringify(e));\n                PRESENCE_HB_TIMEOUT = timeout(_presence_heartbeat, PRESENCE_HB_INTERVAL * SECOND);\n            }\n        });\n    }\n\n    function start_presence_heartbeat() {\n        !PRESENCE_HB_RUNNING && _presence_heartbeat();\n    }\n\n    function _publish(next) {\n\n        if (NO_WAIT_FOR_PENDING) {\n            if (!PUB_QUEUE.length) return;\n        } else {\n            if (next) PUB_QUEUE.sending = 0;\n            if (PUB_QUEUE.sending || !PUB_QUEUE.length) return;\n            PUB_QUEUE.sending = 1;\n        }\n\n        xdr(PUB_QUEUE.shift());\n    }\n    function each_channel_group(callback) {\n        var count = 0;\n\n        each(generate_channel_group_list(CHANNEL_GROUPS), function (channel_group) {\n            var chang = CHANNEL_GROUPS[channel_group];\n\n            if (!chang) return;\n\n            count++;\n            (callback || function () {})(chang);\n        });\n\n        return count;\n    }\n\n    function each_channel(callback) {\n        var count = 0;\n\n        each(generate_channel_list(CHANNELS), function (channel) {\n            var chan = CHANNELS[channel];\n\n            if (!chan) return;\n\n            count++;\n            (callback || function () {})(chan);\n        });\n\n        return count;\n    }\n    function _invoke_callback(response, callback, err) {\n        if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) == 'object') {\n            if (response['error']) {\n                var callback_data = {};\n\n                if (response['message']) {\n                    callback_data['message'] = response['message'];\n                }\n\n                if (response['payload']) {\n                    callback_data['payload'] = response['payload'];\n                }\n\n                err && err(callback_data);\n                return;\n            }\n            if (response['payload']) {\n                if (response['next_page']) callback && callback(response['payload'], response['next_page']);else callback && callback(response['payload']);\n                return;\n            }\n        }\n        callback && callback(response);\n    }\n\n    function _invoke_error(response, err) {\n\n        if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) == 'object' && response['error']) {\n            var callback_data = {};\n\n            if (response['message']) {\n                callback_data['message'] = response['message'];\n            }\n\n            if (response['payload']) {\n                callback_data['payload'] = response['payload'];\n            }\n\n            err && err(callback_data);\n            return;\n        } else {\n            err && err(response);\n        }\n    }\n    function CR(args, callback, url1, data) {\n        var callback = args['callback'] || callback,\n            err = args['error'] || _error,\n            jsonp = jsonp_cb();\n\n        data = data || {};\n\n        if (!data['auth']) {\n            data['auth'] = args['auth_key'] || AUTH_KEY;\n        }\n\n        var url = [STD_ORIGIN, 'v1', 'channel-registration', 'sub-key', SUBSCRIBE_KEY];\n\n        url.push.apply(url, url1);\n\n        if (jsonp) data['callback'] = jsonp;\n\n        xdr({\n            callback: jsonp,\n            data: _get_url_params(data),\n            success: function success(response) {\n                _invoke_callback(response, callback, err);\n            },\n            fail: function fail(response) {\n                _invoke_error(response, err);\n            },\n            url: url\n        });\n    }\n\n    // Announce Leave Event\n    var SELF = {\n        'LEAVE': function LEAVE(channel, blocking, auth_key, callback, error) {\n\n            var data = { 'uuid': UUID, 'auth': auth_key || AUTH_KEY },\n                origin = nextorigin(ORIGIN),\n                callback = callback || function () {},\n                err = error || function () {},\n                url,\n                params,\n                jsonp = jsonp_cb();\n\n            // Prevent Leaving a Presence Channel\n            if (channel.indexOf(PRESENCE_SUFFIX) > 0) return true;\n\n            if (COMPATIBLE_35) {\n                if (!SSL) return false;\n                if (jsonp == '0') return false;\n            }\n\n            if (NOLEAVE) return false;\n\n            if (jsonp != '0') data['callback'] = jsonp;\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            url = [origin, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY, 'channel', encode(channel), 'leave'];\n\n            params = _get_url_params(data);\n\n            if (sendBeacon) {\n                url_string = build_url(url, params);\n                if (sendBeacon(url_string)) {\n                    callback && callback({ \"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\" });\n                    return true;\n                }\n            }\n\n            xdr({\n                blocking: blocking || SSL,\n                timeout: 2000,\n                callback: jsonp,\n                data: params,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n            });\n            return true;\n        },\n        'LEAVE_GROUP': function LEAVE_GROUP(channel_group, blocking, auth_key, callback, error) {\n\n            var data = { 'uuid': UUID, 'auth': auth_key || AUTH_KEY },\n                origin = nextorigin(ORIGIN),\n                url,\n                params,\n                callback = callback || function () {},\n                err = error || function () {},\n                jsonp = jsonp_cb();\n\n            // Prevent Leaving a Presence Channel Group\n            if (channel_group.indexOf(PRESENCE_SUFFIX) > 0) return true;\n\n            if (COMPATIBLE_35) {\n                if (!SSL) return false;\n                if (jsonp == '0') return false;\n            }\n\n            if (NOLEAVE) return false;\n\n            if (jsonp != '0') data['callback'] = jsonp;\n\n            if (channel_group && channel_group.length > 0) data['channel-group'] = channel_group;\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            url = [origin, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY, 'channel', encode(','), 'leave'];\n\n            params = _get_url_params(data);\n\n            if (sendBeacon) {\n                url_string = build_url(url, params);\n                if (sendBeacon(url_string)) {\n                    callback && callback({ \"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\" });\n                    return true;\n                }\n            }\n\n            xdr({\n                blocking: blocking || SSL,\n                timeout: 5000,\n                callback: jsonp,\n                data: params,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n            });\n            return true;\n        },\n        'set_resumed': function set_resumed(resumed) {\n            RESUMED = resumed;\n        },\n        'get_cipher_key': function get_cipher_key() {\n            return CIPHER_KEY;\n        },\n        'set_cipher_key': function set_cipher_key(key) {\n            CIPHER_KEY = key;\n        },\n        'raw_encrypt': function raw_encrypt(input, key) {\n            return encrypt(input, key);\n        },\n        'raw_decrypt': function raw_decrypt(input, key) {\n            return decrypt(input, key);\n        },\n        'get_heartbeat': function get_heartbeat() {\n            return PRESENCE_HB;\n        },\n\n        'set_heartbeat': function set_heartbeat(heartbeat, heartbeat_interval) {\n            PRESENCE_HB = validate_presence_heartbeat(heartbeat, PRESENCE_HB, _error);\n            PRESENCE_HB_INTERVAL = heartbeat_interval || PRESENCE_HB / 2 - 1;\n            if (PRESENCE_HB == 2) {\n                PRESENCE_HB_INTERVAL = 1;\n            }\n            CONNECT();\n            _presence_heartbeat();\n        },\n\n        'get_heartbeat_interval': function get_heartbeat_interval() {\n            return PRESENCE_HB_INTERVAL;\n        },\n\n        'set_heartbeat_interval': function set_heartbeat_interval(heartbeat_interval) {\n            PRESENCE_HB_INTERVAL = heartbeat_interval;\n            _presence_heartbeat();\n        },\n\n        'get_version': function get_version() {\n            return SDK_VER;\n        },\n        'getGcmMessageObject': function getGcmMessageObject(obj) {\n            return {\n                'data': obj\n            };\n        },\n        'getApnsMessageObject': function getApnsMessageObject(obj) {\n            var x = {\n                'aps': { 'badge': 1, 'alert': '' }\n            };\n            for (k in obj) {\n                k[x] = obj[k];\n            }\n            return x;\n        },\n        'newPnMessage': function newPnMessage() {\n            var x = {};\n            if (gcm) x['pn_gcm'] = gcm;\n            if (apns) x['pn_apns'] = apns;\n            for (k in n) {\n                x[k] = n[k];\n            }\n            return x;\n        },\n\n        '_add_param': function _add_param(key, val) {\n            params[key] = val;\n        },\n\n        'channel_group': function channel_group(args, callback) {\n            var ns_ch = args['channel_group'],\n                callback = callback || args['callback'],\n                channels = args['channels'] || args['channel'],\n                cloak = args['cloak'],\n                namespace,\n                channel_group,\n                url = [],\n                data = {},\n                mode = args['mode'] || 'add';\n\n            if (ns_ch) {\n                var ns_ch_a = ns_ch.split(':');\n\n                if (ns_ch_a.length > 1) {\n                    namespace = ns_ch_a[0] === '*' ? null : ns_ch_a[0];\n\n                    channel_group = ns_ch_a[1];\n                } else {\n                    channel_group = ns_ch_a[0];\n                }\n            }\n\n            namespace && url.push('namespace') && url.push(encode(namespace));\n\n            url.push('channel-group');\n\n            if (channel_group && channel_group !== '*') {\n                url.push(channel_group);\n            }\n\n            if (channels) {\n                if (isArray(channels)) {\n                    channels = channels.join(',');\n                }\n                data[mode] = channels;\n                data['cloak'] = CLOAK ? 'true' : 'false';\n            } else {\n                if (mode === 'remove') url.push('remove');\n            }\n\n            if (typeof cloak != 'undefined') data['cloak'] = cloak ? 'true' : 'false';\n\n            CR(args, callback, url, data);\n        },\n\n        'channel_group_list_groups': function channel_group_list_groups(args, callback) {\n            var namespace;\n\n            namespace = args['namespace'] || args['ns'] || args['channel_group'] || null;\n            if (namespace) {\n                args[\"channel_group\"] = namespace + \":*\";\n            }\n\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_list_channels': function channel_group_list_channels(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_remove_channel': function channel_group_remove_channel(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            if (!args['channel'] && !args['channels']) return _error('Missing Channel');\n\n            args['mode'] = 'remove';\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_remove_group': function channel_group_remove_group(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            if (args['channel']) return _error('Use channel_group_remove_channel if you want to remove a channel from a group.');\n\n            args['mode'] = 'remove';\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_add_channel': function channel_group_add_channel(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            if (!args['channel'] && !args['channels']) return _error('Missing Channel');\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_cloak': function channel_group_cloak(args, callback) {\n            if (typeof args['cloak'] == 'undefined') {\n                callback(CLOAK);\n                return;\n            }\n            CLOAK = args['cloak'];\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_list_namespaces': function channel_group_list_namespaces(args, callback) {\n            var url = ['namespace'];\n            CR(args, callback, url);\n        },\n        'channel_group_remove_namespace': function channel_group_remove_namespace(args, callback) {\n            var url = ['namespace', args['namespace'], 'remove'];\n            CR(args, callback, url);\n        },\n\n        /*\n         PUBNUB.history({\n         channel  : 'my_chat_channel',\n         limit    : 100,\n         callback : function(history) { }\n         });\n         */\n        'history': function history(args, callback) {\n            var callback = args['callback'] || callback,\n                count = args['count'] || args['limit'] || 100,\n                reverse = args['reverse'] || \"false\",\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                cipher_key = args['cipher_key'],\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                start = args['start'],\n                end = args['end'],\n                include_token = args['include_token'],\n                string_msg_token = args['string_message_token'] || false,\n                params = {},\n                jsonp = jsonp_cb();\n\n            // Make sure we have a Channel\n            if (!channel && !channel_group) return _error('Missing Channel');\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            params['stringtoken'] = 'true';\n            params['count'] = count;\n            params['reverse'] = reverse;\n            params['auth'] = auth_key;\n\n            if (channel_group) {\n                params['channel-group'] = channel_group;\n                if (!channel) {\n                    channel = ',';\n                }\n            }\n            if (jsonp) params['callback'] = jsonp;\n            if (start) params['start'] = start;\n            if (end) params['end'] = end;\n            if (include_token) params['include_token'] = 'true';\n            if (string_msg_token) params['string_message_token'] = 'true';\n\n            // Send Message\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(params),\n                success: function success(response) {\n                    if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) == 'object' && response['error']) {\n                        err({ 'message': response['message'], 'payload': response['payload'] });\n                        return;\n                    }\n                    var messages = response[0];\n                    var decrypted_messages = [];\n                    for (var a = 0; a < messages.length; a++) {\n                        if (include_token) {\n                            var new_message = decrypt(messages[a]['message'], cipher_key);\n                            var timetoken = messages[a]['timetoken'];\n                            try {\n                                decrypted_messages['push']({ \"message\": JSON['parse'](new_message), \"timetoken\": timetoken });\n                            } catch (e) {\n                                decrypted_messages['push']({ \"message\": new_message, \"timetoken\": timetoken });\n                            }\n                        } else {\n                            var new_message = decrypt(messages[a], cipher_key);\n                            try {\n                                decrypted_messages['push'](JSON['parse'](new_message));\n                            } catch (e) {\n                                decrypted_messages['push'](new_message);\n                            }\n                        }\n                    }\n                    callback([decrypted_messages, response[1], response[2]]);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v2', 'history', 'sub-key', SUBSCRIBE_KEY, 'channel', encode(channel)]\n            });\n        },\n\n        /*\n         PUBNUB.replay({\n         source      : 'my_channel',\n         destination : 'new_channel'\n         });\n         */\n        'replay': function replay(args, callback) {\n            var callback = callback || args['callback'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                source = args['source'],\n                destination = args['destination'],\n                stop = args['stop'],\n                start = args['start'],\n                end = args['end'],\n                reverse = args['reverse'],\n                limit = args['limit'],\n                jsonp = jsonp_cb(),\n                data = {},\n                url;\n\n            // Check User Input\n            if (!source) return _error('Missing Source Channel');\n            if (!destination) return _error('Missing Destination Channel');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            // Setup URL Params\n            if (jsonp != '0') data['callback'] = jsonp;\n            if (stop) data['stop'] = 'all';\n            if (reverse) data['reverse'] = 'true';\n            if (start) data['start'] = start;\n            if (end) data['end'] = end;\n            if (limit) data['count'] = limit;\n\n            data['auth'] = auth_key;\n\n            // Compose URL Parts\n            url = [STD_ORIGIN, 'v1', 'replay', PUBLISH_KEY, SUBSCRIBE_KEY, source, destination];\n\n            // Start (or Stop) Replay!\n            xdr({\n                callback: jsonp,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail() {\n                    callback([0, 'Disconnected']);\n                },\n                url: url,\n                data: _get_url_params(data)\n            });\n        },\n\n        /*\n         PUBNUB.auth('AJFLKAJSDKLA');\n         */\n        'auth': function auth(_auth) {\n            AUTH_KEY = _auth;\n            CONNECT();\n        },\n\n        /*\n         PUBNUB.time(function(time){ });\n         */\n        'time': function time(callback) {\n            var jsonp = jsonp_cb();\n\n            var data = { 'uuid': UUID, 'auth': AUTH_KEY };\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                timeout: SECOND * 5,\n                url: [STD_ORIGIN, 'time', jsonp],\n                success: function success(response) {\n                    callback(response[0]);\n                },\n                fail: function fail() {\n                    callback(0);\n                }\n            });\n        },\n\n        /*\n         PUBNUB.publish({\n         channel : 'my_chat_channel',\n         message : 'hello!'\n         });\n         */\n        'publish': function publish(args, callback) {\n            var msg = args['message'];\n            if (!msg) return _error('Missing Message');\n\n            var callback = callback || args['callback'] || msg['callback'] || function () {},\n                channel = args['channel'] || msg['channel'],\n                auth_key = args['auth_key'] || AUTH_KEY,\n                cipher_key = args['cipher_key'],\n                err = args['error'] || msg['error'] || function () {},\n                post = args['post'] || false,\n                store = 'store_in_history' in args ? args['store_in_history'] : true,\n                jsonp = jsonp_cb(),\n                add_msg = 'push',\n                params,\n                url;\n\n            if (args['prepend']) add_msg = 'unshift';\n\n            if (!channel) return _error('Missing Channel');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            if (msg['getPubnubMessage']) {\n                msg = msg['getPubnubMessage']();\n            }\n\n            // If trying to send Object\n            msg = JSON['stringify'](encrypt(msg, cipher_key));\n\n            // Create URL\n            url = [STD_ORIGIN, 'publish', PUBLISH_KEY, SUBSCRIBE_KEY, 0, encode(channel), jsonp, encode(msg)];\n\n            params = { 'uuid': UUID, 'auth': auth_key };\n\n            if (!store) params['store'] = \"0\";\n\n            if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;\n\n            // Queue Message Send\n            PUB_QUEUE[add_msg]({\n                callback: jsonp,\n                timeout: SECOND * 5,\n                url: url,\n                data: _get_url_params(params),\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                    _publish(1);\n                },\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                    _publish(1);\n                },\n                mode: post ? 'POST' : 'GET'\n            });\n\n            // Send Message\n            _publish();\n        },\n\n        /*\n         PUBNUB.unsubscribe({ channel : 'my_chat' });\n         */\n        'unsubscribe': function unsubscribe(args, callback) {\n            var channel = args['channel'],\n                channel_group = args['channel_group'],\n                auth_key = args['auth_key'] || AUTH_KEY,\n                callback = callback || args['callback'] || function () {},\n                err = args['error'] || function () {};\n\n            TIMETOKEN = 0;\n            SUB_RESTORE = 1; // REVISIT !!!!\n\n            if (channel) {\n\n                // Prepare LeaveChannel(s)\n                var leave_c = map((channel.join ? channel.join(',') : '' + channel).split(','), function (channel) {\n                    if (!CHANNELS[channel]) return;\n                    return channel;\n                }).join(',');\n\n                // Prepare Channel(s)\n                channel = map((channel.join ? channel.join(',') : '' + channel).split(','), function (channel) {\n                    if (!CHANNELS[channel]) return;\n                    return channel + ',' + channel + PRESENCE_SUFFIX;\n                }).join(',');\n\n                // Iterate over Channels\n                each(channel.split(','), function (ch) {\n                    if (!ch) return;\n                    CHANNELS[ch] = 0;\n                    if (ch in STATE) delete STATE[ch];\n                });\n\n                var CB_CALLED = true;\n                if (READY) {\n                    CB_CALLED = SELF['LEAVE'](leave_c, 0, auth_key, callback, err);\n                }\n                if (!CB_CALLED) callback({ action: \"leave\" });\n            }\n\n            if (channel_group) {\n\n                // Prepare channel group(s)\n                var leave_gc = map((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','), function (channel_group) {\n                    if (!CHANNEL_GROUPS[channel_group]) return;\n                    return channel_group;\n                }).join(',');\n\n                // Prepare channel group(s)\n                channel_group = map((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','), function (channel_group) {\n                    if (!CHANNEL_GROUPS[channel_group]) return;\n                    return channel_group + ',' + channel_group + PRESENCE_SUFFIX;\n                }).join(',');\n\n                // Iterate over channel groups\n                each(channel_group.split(','), function (chg) {\n                    if (!chg) return;\n                    CHANNEL_GROUPS[chg] = 0;\n                    if (chg in STATE) delete STATE[chg];\n                });\n\n                var CB_CALLED = true;\n                if (READY) {\n                    CB_CALLED = SELF['LEAVE_GROUP'](leave_gc, 0, auth_key, callback, err);\n                }\n                if (!CB_CALLED) callback({ action: \"leave\" });\n            }\n\n            // Reset Connection if Count Less\n            CONNECT();\n        },\n\n        /*\n         PUBNUB.subscribe({\n         channel  : 'my_chat'\n         callback : function(message) { }\n         });\n         */\n        'subscribe': function subscribe(args, callback) {\n            var channel = args['channel'],\n                channel_group = args['channel_group'],\n                callback = callback || args['callback'],\n                callback = callback || args['message'],\n                connect = args['connect'] || function () {},\n                reconnect = args['reconnect'] || function () {},\n                disconnect = args['disconnect'] || function () {},\n                SUB_ERROR = args['error'] || SUB_ERROR || function () {},\n                idlecb = args['idle'] || function () {},\n                presence = args['presence'] || 0,\n                noheresync = args['noheresync'] || 0,\n                backfill = args['backfill'] || 0,\n                timetoken = args['timetoken'] || 0,\n                sub_timeout = args['timeout'] || SUB_TIMEOUT,\n                windowing = args['windowing'] || SUB_WINDOWING,\n                state = args['state'],\n                heartbeat = args['heartbeat'] || args['pnexpires'],\n                heartbeat_interval = args['heartbeat_interval'],\n                restore = args['restore'] || SUB_RESTORE;\n\n            AUTH_KEY = args['auth_key'] || AUTH_KEY;\n\n            // Restore Enabled?\n            SUB_RESTORE = restore;\n\n            // Always Reset the TT\n            TIMETOKEN = timetoken;\n\n            // Make sure we have a Channel\n            if (!channel && !channel_group) {\n                return _error('Missing Channel');\n            }\n\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            if (heartbeat || heartbeat === 0 || heartbeat_interval || heartbeat_interval === 0) {\n                SELF['set_heartbeat'](heartbeat, heartbeat_interval);\n            }\n\n            // Setup Channel(s)\n            if (channel) {\n                each((channel.join ? channel.join(',') : '' + channel).split(','), function (channel) {\n                    var settings = CHANNELS[channel] || {};\n\n                    // Store Channel State\n                    CHANNELS[SUB_CHANNEL = channel] = {\n                        name: channel,\n                        connected: settings.connected,\n                        disconnected: settings.disconnected,\n                        subscribed: 1,\n                        callback: SUB_CALLBACK = callback,\n                        'cipher_key': args['cipher_key'],\n                        connect: connect,\n                        disconnect: disconnect,\n                        reconnect: reconnect\n                    };\n\n                    if (state) {\n                        if (channel in state) {\n                            STATE[channel] = state[channel];\n                        } else {\n                            STATE[channel] = state;\n                        }\n                    }\n\n                    // Presence Enabled?\n                    if (!presence) return;\n\n                    // Subscribe Presence Channel\n                    SELF['subscribe']({\n                        'channel': channel + PRESENCE_SUFFIX,\n                        'callback': presence,\n                        'restore': restore\n                    });\n\n                    // Presence Subscribed?\n                    if (settings.subscribed) return;\n\n                    // See Who's Here Now?\n                    if (noheresync) return;\n                    SELF['here_now']({\n                        'channel': channel,\n                        'data': _get_url_params({ 'uuid': UUID, 'auth': AUTH_KEY }),\n                        'callback': function callback(here) {\n                            each('uuids' in here ? here['uuids'] : [], function (uid) {\n                                presence({\n                                    'action': 'join',\n                                    'uuid': uid,\n                                    'timestamp': Math.floor(rnow() / 1000),\n                                    'occupancy': here['occupancy'] || 1\n                                }, here, channel);\n                            });\n                        }\n                    });\n                });\n            }\n\n            // Setup Channel Groups\n            if (channel_group) {\n                each((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','), function (channel_group) {\n                    var settings = CHANNEL_GROUPS[channel_group] || {};\n\n                    CHANNEL_GROUPS[channel_group] = {\n                        name: channel_group,\n                        connected: settings.connected,\n                        disconnected: settings.disconnected,\n                        subscribed: 1,\n                        callback: SUB_CALLBACK = callback,\n                        'cipher_key': args['cipher_key'],\n                        connect: connect,\n                        disconnect: disconnect,\n                        reconnect: reconnect\n                    };\n\n                    // Presence Enabled?\n                    if (!presence) return;\n\n                    // Subscribe Presence Channel\n                    SELF['subscribe']({\n                        'channel_group': channel_group + PRESENCE_SUFFIX,\n                        'callback': presence,\n                        'restore': restore,\n                        'auth_key': AUTH_KEY\n                    });\n\n                    // Presence Subscribed?\n                    if (settings.subscribed) return;\n\n                    // See Who's Here Now?\n                    if (noheresync) return;\n                    SELF['here_now']({\n                        'channel_group': channel_group,\n                        'data': _get_url_params({ 'uuid': UUID, 'auth': AUTH_KEY }),\n                        'callback': function callback(here) {\n                            each('uuids' in here ? here['uuids'] : [], function (uid) {\n                                presence({\n                                    'action': 'join',\n                                    'uuid': uid,\n                                    'timestamp': Math.floor(rnow() / 1000),\n                                    'occupancy': here['occupancy'] || 1\n                                }, here, channel_group);\n                            });\n                        }\n                    });\n                });\n            }\n\n            // Test Network Connection\n            function _test_connection(success) {\n                if (success) {\n                    // Begin Next Socket Connection\n                    timeout(CONNECT, windowing);\n                } else {\n                    // New Origin on Failed Connection\n                    STD_ORIGIN = nextorigin(ORIGIN, 1);\n                    SUB_ORIGIN = nextorigin(ORIGIN, 1);\n\n                    // Re-test Connection\n                    timeout(function () {\n                        SELF['time'](_test_connection);\n                    }, SECOND);\n                }\n\n                // Disconnect & Reconnect\n                each_channel(function (channel) {\n                    // Reconnect\n                    if (success && channel.disconnected) {\n                        channel.disconnected = 0;\n                        return channel.reconnect(channel.name);\n                    }\n\n                    // Disconnect\n                    if (!success && !channel.disconnected) {\n                        channel.disconnected = 1;\n                        channel.disconnect(channel.name);\n                    }\n                });\n\n                // Disconnect & Reconnect for channel groups\n                each_channel_group(function (channel_group) {\n                    // Reconnect\n                    if (success && channel_group.disconnected) {\n                        channel_group.disconnected = 0;\n                        return channel_group.reconnect(channel_group.name);\n                    }\n\n                    // Disconnect\n                    if (!success && !channel_group.disconnected) {\n                        channel_group.disconnected = 1;\n                        channel_group.disconnect(channel_group.name);\n                    }\n                });\n            }\n\n            // Evented Subscribe\n            function _connect() {\n                var jsonp = jsonp_cb(),\n                    channels = generate_channel_list(CHANNELS).join(','),\n                    channel_groups = generate_channel_group_list(CHANNEL_GROUPS).join(',');\n\n                // Stop Connection\n                if (!channels && !channel_groups) return;\n\n                if (!channels) channels = ',';\n\n                // Connect to PubNub Subscribe Servers\n                _reset_offline();\n\n                var data = _get_url_params({ 'uuid': UUID, 'auth': AUTH_KEY });\n\n                if (channel_groups) {\n                    data['channel-group'] = channel_groups;\n                }\n\n                var st = JSON.stringify(STATE);\n                if (st.length > 2) data['state'] = JSON.stringify(STATE);\n\n                if (PRESENCE_HB) data['heartbeat'] = PRESENCE_HB;\n\n                if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n                start_presence_heartbeat();\n                SUB_RECEIVER = xdr({\n                    timeout: sub_timeout,\n                    callback: jsonp,\n                    fail: function fail(response) {\n                        if (response && response['error'] && response['service']) {\n                            _invoke_error(response, SUB_ERROR);\n                            _test_connection(1);\n                        } else {\n                            SELF['time'](function (success) {\n                                !success && _invoke_error(response, SUB_ERROR);\n                                _test_connection(success);\n                            });\n                        }\n                    },\n                    data: _get_url_params(data),\n                    url: [SUB_ORIGIN, 'subscribe', SUBSCRIBE_KEY, encode(channels), jsonp, TIMETOKEN],\n                    success: function success(messages) {\n\n                        // Check for Errors\n                        if (!messages || (typeof messages === 'undefined' ? 'undefined' : _typeof(messages)) == 'object' && 'error' in messages && messages['error']) {\n                            SUB_ERROR(messages['error']);\n                            return timeout(CONNECT, SECOND);\n                        }\n\n                        // User Idle Callback\n                        idlecb(messages[1]);\n\n                        // Restore Previous Connection Point if Needed\n                        TIMETOKEN = !TIMETOKEN && SUB_RESTORE && db['get'](SUBSCRIBE_KEY) || messages[1];\n\n                        /*\n                         // Connect\n                         each_channel_registry(function(registry){\n                         if (registry.connected) return;\n                         registry.connected = 1;\n                         registry.connect(channel.name);\n                         });\n                         */\n\n                        // Connect\n                        each_channel(function (channel) {\n                            if (channel.connected) return;\n                            channel.connected = 1;\n                            channel.connect(channel.name);\n                        });\n\n                        // Connect for channel groups\n                        each_channel_group(function (channel_group) {\n                            if (channel_group.connected) return;\n                            channel_group.connected = 1;\n                            channel_group.connect(channel_group.name);\n                        });\n\n                        if (RESUMED && !SUB_RESTORE) {\n                            TIMETOKEN = 0;\n                            RESUMED = false;\n                            // Update Saved Timetoken\n                            db['set'](SUBSCRIBE_KEY, 0);\n                            timeout(_connect, windowing);\n                            return;\n                        }\n\n                        // Invoke Memory Catchup and Receive Up to 100\n                        // Previous Messages from the Queue.\n                        if (backfill) {\n                            TIMETOKEN = 10000;\n                            backfill = 0;\n                        }\n\n                        // Update Saved Timetoken\n                        db['set'](SUBSCRIBE_KEY, messages[1]);\n\n                        // Route Channel <---> Callback for Message\n                        var next_callback = (function () {\n                            var channels = '';\n                            var channels2 = '';\n\n                            if (messages.length > 3) {\n                                channels = messages[3];\n                                channels2 = messages[2];\n                            } else if (messages.length > 2) {\n                                channels = messages[2];\n                            } else {\n                                channels = map(generate_channel_list(CHANNELS), function (chan) {\n                                    return map(Array(messages[0].length).join(',').split(','), function () {\n                                        return chan;\n                                    });\n                                }).join(',');\n                            }\n\n                            var list = channels.split(',');\n                            var list2 = channels2 ? channels2.split(',') : [];\n\n                            return function () {\n                                var channel = list.shift() || SUB_CHANNEL;\n                                var channel2 = list2.shift();\n\n                                var chobj = {};\n\n                                if (channel2) {\n                                    if (channel && channel.indexOf('-pnpres') >= 0 && channel2.indexOf('-pnpres') < 0) {\n                                        channel2 += '-pnpres';\n                                    }\n                                    chobj = CHANNEL_GROUPS[channel2] || CHANNELS[channel2] || { 'callback': function callback() {} };\n                                } else {\n                                    chobj = CHANNELS[channel];\n                                }\n\n                                var r = [chobj.callback || SUB_CALLBACK, channel.split(PRESENCE_SUFFIX)[0]];\n                                channel2 && r.push(channel2.split(PRESENCE_SUFFIX)[0]);\n                                return r;\n                            };\n                        })();\n\n                        var latency = detect_latency(+messages[1]);\n                        each(messages[0], function (msg) {\n                            var next = next_callback();\n                            var decrypted_msg = decrypt(msg, CHANNELS[next[1]] ? CHANNELS[next[1]]['cipher_key'] : null);\n                            next[0] && next[0](decrypted_msg, messages, next[2] || next[1], latency, next[1]);\n                        });\n\n                        timeout(_connect, windowing);\n                    }\n                });\n            }\n\n            CONNECT = function () {\n                _reset_offline();\n                timeout(_connect, windowing);\n            };\n\n            // Reduce Status Flicker\n            if (!READY) return READY_BUFFER.push(CONNECT);\n\n            // Connect Now\n            CONNECT();\n        },\n\n        /*\n         PUBNUB.here_now({ channel : 'my_chat', callback : fun });\n         */\n        'here_now': function here_now(args, callback) {\n            var callback = args['callback'] || callback,\n                debug = args['debug'],\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                jsonp = jsonp_cb(),\n                uuids = 'uuids' in args ? args['uuids'] : true,\n                state = args['state'],\n                data = { 'uuid': UUID, 'auth': auth_key };\n\n            if (!uuids) data['disable_uuids'] = 1;\n            if (state) data['state'] = 1;\n\n            // Make sure we have a Channel\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            var url = [STD_ORIGIN, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY];\n\n            channel && url.push('channel') && url.push(encode(channel));\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            if (channel_group) {\n                data['channel-group'] = channel_group;\n                !channel && url.push('channel') && url.push(',');\n            }\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                debug: debug,\n                url: url\n            });\n        },\n\n        /*\n         PUBNUB.current_channels_by_uuid({ channel : 'my_chat', callback : fun });\n         */\n        'where_now': function where_now(args, callback) {\n            var callback = args['callback'] || callback,\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                jsonp = jsonp_cb(),\n                uuid = args['uuid'] || UUID,\n                data = { 'auth': auth_key };\n\n            // Make sure we have a Channel\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY, 'uuid', encode(uuid)]\n            });\n        },\n\n        'state': function state(args, callback) {\n            var callback = args['callback'] || callback || function (r) {},\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                jsonp = jsonp_cb(),\n                state = args['state'],\n                uuid = args['uuid'] || UUID,\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                url,\n                data = _get_url_params({ 'auth': auth_key });\n\n            // Make sure we have a Channel\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n            if (!uuid) return _error('Missing UUID');\n            if (!channel && !channel_group) return _error('Missing Channel');\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            if (typeof channel != 'undefined' && CHANNELS[channel] && CHANNELS[channel].subscribed) {\n                if (state) STATE[channel] = state;\n            }\n\n            if (typeof channel_group != 'undefined' && CHANNEL_GROUPS[channel_group] && CHANNEL_GROUPS[channel_group].subscribed) {\n                if (state) STATE[channel_group] = state;\n                data['channel-group'] = channel_group;\n\n                if (!channel) {\n                    channel = ',';\n                }\n            }\n\n            data['state'] = JSON.stringify(state);\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            if (state) {\n                url = [STD_ORIGIN, 'v2', 'presence', 'sub-key', SUBSCRIBE_KEY, 'channel', channel, 'uuid', uuid, 'data'];\n            } else {\n                url = [STD_ORIGIN, 'v2', 'presence', 'sub-key', SUBSCRIBE_KEY, 'channel', channel, 'uuid', encode(uuid)];\n            }\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n\n            });\n        },\n\n        /*\n         PUBNUB.grant({\n         channel  : 'my_chat',\n         callback : fun,\n         error    : fun,\n         ttl      : 24 * 60, // Minutes\n         read     : true,\n         write    : true,\n         auth_key : '3y8uiajdklytowsj'\n         });\n         */\n        'grant': function grant(args, callback) {\n            var callback = args['callback'] || callback,\n                err = args['error'] || function () {},\n                channel = args['channel'] || args['channels'],\n                channel_group = args['channel_group'],\n                jsonp = jsonp_cb(),\n                ttl = args['ttl'],\n                r = args['read'] ? \"1\" : \"0\",\n                w = args['write'] ? \"1\" : \"0\",\n                m = args['manage'] ? \"1\" : \"0\",\n                auth_key = args['auth_key'] || args['auth_keys'];\n\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SECRET_KEY) return _error('Missing Secret Key');\n\n            var timestamp = Math.floor(new Date().getTime() / 1000),\n                sign_input = SUBSCRIBE_KEY + \"\\n\" + PUBLISH_KEY + \"\\n\" + \"grant\" + \"\\n\";\n\n            var data = {\n                'w': w,\n                'r': r,\n                'timestamp': timestamp\n            };\n            if (args['manage']) {\n                data['m'] = m;\n            }\n            if (isArray(channel)) {\n                channel = channel['join'](',');\n            }\n            if (isArray(auth_key)) {\n                auth_key = auth_key['join'](',');\n            }\n            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n                data['channel-group'] = channel_group;\n            }\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n            if (ttl || ttl === 0) data['ttl'] = ttl;\n\n            if (auth_key) data['auth'] = auth_key;\n\n            data = _get_url_params(data);\n\n            if (!auth_key) delete data['auth'];\n\n            sign_input += _get_pam_sign_input_from_params(data);\n\n            var signature = hmac_SHA256(sign_input, SECRET_KEY);\n\n            signature = signature.replace(/\\+/g, \"-\");\n            signature = signature.replace(/\\//g, \"_\");\n\n            data['signature'] = signature;\n\n            xdr({\n                callback: jsonp,\n                data: data,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v1', 'auth', 'grant', 'sub-key', SUBSCRIBE_KEY]\n            });\n        },\n\n        /*\n         PUBNUB.mobile_gw_provision ({\n         device_id: 'A655FBA9931AB',\n         op       : 'add' | 'remove',\n         gw_type  : 'apns' | 'gcm',\n         channel  : 'my_chat',\n         callback : fun,\n         error    : fun,\n         });\n         */\n\n        'mobile_gw_provision': function mobile_gw_provision(args) {\n\n            var callback = args['callback'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                err = args['error'] || function () {},\n                jsonp = jsonp_cb(),\n                channel = args['channel'],\n                op = args['op'],\n                gw_type = args['gw_type'],\n                device_id = args['device_id'],\n                params,\n                url;\n\n            if (!device_id) return _error('Missing Device ID (device_id)');\n            if (!gw_type) return _error('Missing GW Type (gw_type: gcm or apns)');\n            if (!op) return _error('Missing GW Operation (op: add or remove)');\n            if (!channel) return _error('Missing gw destination Channel (channel)');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            // Create URL\n            url = [STD_ORIGIN, 'v1/push/sub-key', SUBSCRIBE_KEY, 'devices', device_id];\n\n            params = { 'uuid': UUID, 'auth': auth_key, 'type': gw_type };\n\n            if (op == \"add\") {\n                params['add'] = channel;\n            } else if (op == \"remove\") {\n                params['remove'] = channel;\n            }\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: params,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n            });\n        },\n\n        /*\n         PUBNUB.audit({\n         channel  : 'my_chat',\n         callback : fun,\n         error    : fun,\n         read     : true,\n         write    : true,\n         auth_key : '3y8uiajdklytowsj'\n         });\n         */\n        'audit': function audit(args, callback) {\n            var callback = args['callback'] || callback,\n                err = args['error'] || function () {},\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                auth_key = args['auth_key'],\n                jsonp = jsonp_cb();\n\n            // Make sure we have a Channel\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SECRET_KEY) return _error('Missing Secret Key');\n\n            var timestamp = Math.floor(new Date().getTime() / 1000),\n                sign_input = SUBSCRIBE_KEY + \"\\n\" + PUBLISH_KEY + \"\\n\" + \"audit\" + \"\\n\";\n\n            var data = { 'timestamp': timestamp };\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n                data['channel-group'] = channel_group;\n            }\n            if (auth_key) data['auth'] = auth_key;\n\n            data = _get_url_params(data);\n\n            if (!auth_key) delete data['auth'];\n\n            sign_input += _get_pam_sign_input_from_params(data);\n\n            var signature = hmac_SHA256(sign_input, SECRET_KEY);\n\n            signature = signature.replace(/\\+/g, \"-\");\n            signature = signature.replace(/\\//g, \"_\");\n\n            data['signature'] = signature;\n            xdr({\n                callback: jsonp,\n                data: data,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v1', 'auth', 'audit', 'sub-key', SUBSCRIBE_KEY]\n            });\n        },\n\n        /*\n         PUBNUB.revoke({\n         channel  : 'my_chat',\n         callback : fun,\n         error    : fun,\n         auth_key : '3y8uiajdklytowsj'\n         });\n         */\n        'revoke': function revoke(args, callback) {\n            args['read'] = false;\n            args['write'] = false;\n            SELF['grant'](args, callback);\n        },\n        'set_uuid': function set_uuid(uuid) {\n            UUID = uuid;\n            CONNECT();\n        },\n        'get_uuid': function get_uuid() {\n            return UUID;\n        },\n        'isArray': (function (_isArray) {\n            function isArray(_x) {\n                return _isArray.apply(this, arguments);\n            }\n\n            isArray.toString = function () {\n                return _isArray.toString();\n            };\n\n            return isArray;\n        })(function (arg) {\n            return isArray(arg);\n        }),\n        'get_subscibed_channels': function get_subscibed_channels() {\n            return generate_channel_list(CHANNELS, true);\n        },\n        'presence_heartbeat': function presence_heartbeat(args) {\n            var callback = args['callback'] || function () {};\n            var err = args['error'] || function () {};\n            var jsonp = jsonp_cb();\n            var data = { 'uuid': UUID, 'auth': AUTH_KEY };\n\n            var st = JSON['stringify'](STATE);\n            if (st.length > 2) data['state'] = JSON['stringify'](STATE);\n\n            if (PRESENCE_HB > 0 && PRESENCE_HB < 320) data['heartbeat'] = PRESENCE_HB;\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            var channels = encode(generate_channel_list(CHANNELS, true)['join'](','));\n            var channel_groups = generate_channel_group_list(CHANNEL_GROUPS, true)['join'](',');\n\n            if (!channels) channels = ',';\n            if (channel_groups) data['channel-group'] = channel_groups;\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                timeout: SECOND * 5,\n                url: [STD_ORIGIN, 'v2', 'presence', 'sub-key', SUBSCRIBE_KEY, 'channel', channels, 'heartbeat'],\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                }\n            });\n        },\n        'stop_timers': function stop_timers() {\n            clearTimeout(_poll_timer);\n            clearTimeout(_poll_timer2);\n            clearTimeout(PRESENCE_HB_TIMEOUT);\n        },\n        'shutdown': function shutdown() {\n            SELF['stop_timers']();\n            _shutdown && _shutdown();\n        },\n\n        // Expose PUBNUB Functions\n        'xdr': xdr,\n        'ready': ready,\n        'db': db,\n        'uuid': generate_uuid,\n        'map': map,\n        'each': each,\n        'each-channel': each_channel,\n        'grep': grep,\n        'offline': function offline() {\n            _reset_offline(1, { \"message\": \"Offline. Please check your network settings.\" });\n        },\n        'supplant': supplant,\n        'now': rnow,\n        'unique': unique,\n        'updater': updater\n    };\n\n    function _poll_online() {\n        _is_online() || _reset_offline(1, {\n            \"error\": \"Offline. Please check your network settings. \"\n        });\n        _poll_timer && clearTimeout(_poll_timer);\n        _poll_timer = timeout(_poll_online, SECOND);\n    }\n\n    function _poll_online2() {\n        if (!TIME_CHECK) return;\n        SELF['time'](function (success) {\n            detect_time_detla(function () {}, success);\n            success || _reset_offline(1, {\n                \"error\": \"Heartbeat failed to connect to Pubnub Servers.\" + \"Please check your network settings.\"\n            });\n            _poll_timer2 && clearTimeout(_poll_timer2);\n            _poll_timer2 = timeout(_poll_online2, KEEPALIVE);\n        });\n    }\n\n    function _reset_offline(err, msg) {\n        SUB_RECEIVER && SUB_RECEIVER(err, msg);\n        SUB_RECEIVER = null;\n\n        clearTimeout(_poll_timer);\n        clearTimeout(_poll_timer2);\n    }\n\n    if (!UUID) UUID = SELF['uuid']();\n    if (!INSTANCEID) INSTANCEID = SELF['uuid']();\n    db['set'](SUBSCRIBE_KEY + 'uuid', UUID);\n\n    _poll_timer = timeout(_poll_online, SECOND);\n    _poll_timer2 = timeout(_poll_online2, KEEPALIVE);\n    PRESENCE_HB_TIMEOUT = timeout(start_presence_heartbeat, (PRESENCE_HB_INTERVAL - 3) * SECOND);\n\n    // Detect Age of Message\n    function detect_latency(tt) {\n        var adjusted_time = rnow() - TIME_DRIFT;\n        return adjusted_time - tt / 10000;\n    }\n\n    detect_time_detla();\n    function detect_time_detla(cb, time) {\n        var stime = rnow();\n\n        time && calculate(time) || SELF['time'](calculate);\n\n        function calculate(time) {\n            if (!time) return;\n            var ptime = time / 10000,\n                latency = (rnow() - stime) / 2;\n            TIME_DRIFT = rnow() - (ptime + latency);\n            cb && cb(TIME_DRIFT);\n        }\n    }\n\n    return SELF;\n}","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar _package = require('../package.json');\n\nfunction _typeof(obj) { return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }\n\nvar NOW = 1;\nvar READY = false;\nvar READY_BUFFER = [];\nvar PRESENCE_SUFFIX = '-pnpres';\nvar DEF_WINDOWING = 10; // MILLISECONDS.\nvar DEF_TIMEOUT = 10000; // MILLISECONDS.\nvar DEF_SUB_TIMEOUT = 310; // SECONDS.\nvar DEF_KEEPALIVE = 60; // SECONDS (FOR TIMESYNC).\nvar SECOND = 1000; // A THOUSAND MILLISECONDS.\nvar URLBIT = '/';\nvar PARAMSBIT = '&';\nvar PRESENCE_HB_THRESHOLD = 5;\nvar PRESENCE_HB_DEFAULT = 30;\nvar SDK_VER = _package.version;\nvar REPL = /{([\\w\\-]+)}/g;\n\n/**\n * Generate Subscription Channel List\n * ==================================\n * generate_channel_list(channels_object);\n */\nfunction generate_channel_list(channels, nopresence) {\n    var list = [];\n    each(channels, function (channel, status) {\n        if (nopresence) {\n            if (channel.search('-pnpres') < 0) {\n                if (status.subscribed) list.push(channel);\n            }\n        } else {\n            if (status.subscribed) list.push(channel);\n        }\n    });\n    return list.sort();\n}\n\n/**\n * Generate Subscription Channel Groups List\n * ==================================\n * generate_channel_group_list(channels_groups object);\n */\nfunction generate_channel_group_list(channel_groups, nopresence) {\n    var list = [];\n    each(channel_groups, function (channel_group, status) {\n        if (nopresence) {\n            if (channel_group.search('-pnpres') < 0) {\n                if (status.subscribed) list.push(channel_group);\n            }\n        } else {\n            if (status.subscribed) list.push(channel_group);\n        }\n    });\n    return list.sort();\n}\n\n// PUBNUB READY TO CONNECT\nfunction ready() {\n    timeout(function () {\n        if (READY) return;\n        READY = 1;\n        each(READY_BUFFER, function (connect) {\n            connect();\n        });\n    }, SECOND);\n}\n\nfunction PNmessage(args) {\n    msg = args || { 'apns': {} }, msg['getPubnubMessage'] = function () {\n        var m = {};\n\n        if (Object.keys(msg['apns']).length) {\n            m['pn_apns'] = {\n                'aps': {\n                    'alert': msg['apns']['alert'],\n                    'badge': msg['apns']['badge']\n                }\n            };\n            for (var k in msg['apns']) {\n                m['pn_apns'][k] = msg['apns'][k];\n            }\n            var exclude1 = ['badge', 'alert'];\n            for (var k in exclude1) {\n                delete m['pn_apns'][exclude1[k]];\n            }\n        }\n\n        if (msg['gcm']) {\n            m['pn_gcm'] = {\n                'data': msg['gcm']\n            };\n        }\n\n        for (var k in msg) {\n            m[k] = msg[k];\n        }\n        var exclude = ['apns', 'gcm', 'publish', 'channel', 'callback', 'error'];\n        for (var k in exclude) {\n            delete m[exclude[k]];\n        }\n\n        return m;\n    };\n    msg['publish'] = function () {\n\n        var m = msg.getPubnubMessage();\n\n        if (msg['pubnub'] && msg['channel']) {\n            msg['pubnub'].publish({\n                'message': m,\n                'channel': msg['channel'],\n                'callback': msg['callback'],\n                'error': msg['error']\n            });\n        }\n    };\n    return msg;\n}\n\nfunction PN_API(setup) {\n    var SUB_WINDOWING = +setup['windowing'] || DEF_WINDOWING,\n        SUB_TIMEOUT = (+setup['timeout'] || DEF_SUB_TIMEOUT) * SECOND,\n        KEEPALIVE = (+setup['keepalive'] || DEF_KEEPALIVE) * SECOND,\n        TIME_CHECK = setup['timecheck'] || 0,\n        NOLEAVE = setup['noleave'] || 0,\n        PUBLISH_KEY = setup['publish_key'],\n        SUBSCRIBE_KEY = setup['subscribe_key'],\n        AUTH_KEY = setup['auth_key'] || '',\n        SECRET_KEY = setup['secret_key'] || '',\n        hmac_SHA256 = setup['hmac_SHA256'],\n        SSL = setup['ssl'] ? 's' : '',\n        ORIGIN = 'http' + SSL + '://' + (setup['origin'] || 'pubsub.pubnub.com'),\n        STD_ORIGIN = nextorigin(ORIGIN),\n        SUB_ORIGIN = nextorigin(ORIGIN),\n        CONNECT = function CONNECT() {},\n        PUB_QUEUE = [],\n        CLOAK = true,\n        TIME_DRIFT = 0,\n        SUB_CALLBACK = 0,\n        SUB_CHANNEL = 0,\n        SUB_RECEIVER = 0,\n        SUB_RESTORE = setup['restore'] || 0,\n        SUB_BUFF_WAIT = 0,\n        TIMETOKEN = 0,\n        RESUMED = false,\n        CHANNELS = {},\n        CHANNEL_GROUPS = {},\n        SUB_ERROR = function SUB_ERROR() {},\n        STATE = {},\n        PRESENCE_HB_TIMEOUT = null,\n        PRESENCE_HB = validate_presence_heartbeat(setup['heartbeat'] || setup['pnexpires'] || 0, setup['error']),\n        PRESENCE_HB_INTERVAL = setup['heartbeat_interval'] || PRESENCE_HB / 2 - 1,\n        PRESENCE_HB_RUNNING = false,\n        NO_WAIT_FOR_PENDING = setup['no_wait_for_pending'],\n        COMPATIBLE_35 = setup['compatible_3.5'] || false,\n        xdr = setup['xdr'],\n        params = setup['params'] || {},\n        _error = setup['error'] || function () {},\n        _is_online = setup['_is_online'] || function () {\n        return 1;\n    },\n        jsonp_cb = setup['jsonp_cb'] || function () {\n        return 0;\n    },\n        db = setup['db'] || { 'get': function get() {}, 'set': function set() {} },\n        CIPHER_KEY = setup['cipher_key'],\n        UUID = setup['uuid'] || !setup['unique_uuid'] && db && db['get'](SUBSCRIBE_KEY + 'uuid') || '',\n        USE_INSTANCEID = setup['instance_id'] || false,\n        INSTANCEID = '',\n        _shutdown = setup['shutdown'],\n        use_send_beacon = typeof setup['use_send_beacon'] != 'undefined' ? setup['use_send_beacon'] : true,\n        sendBeacon = use_send_beacon ? setup['sendBeacon'] : null,\n        _poll_timer,\n        _poll_timer2;\n\n    if (PRESENCE_HB === 2) PRESENCE_HB_INTERVAL = 1;\n\n    var crypto_obj = setup['crypto_obj'] || {\n        'encrypt': function encrypt(a, key) {\n            return a;\n        },\n        'decrypt': function decrypt(b, key) {\n            return b;\n        }\n    };\n\n    function _get_url_params(data) {\n        if (!data) data = {};\n        each(params, function (key, value) {\n            if (!(key in data)) data[key] = value;\n        });\n        return data;\n    }\n\n    function _object_to_key_list(o) {\n        var l = [];\n        each(o, function (key, value) {\n            l.push(key);\n        });\n        return l;\n    }\n    function _object_to_key_list_sorted(o) {\n        return _object_to_key_list(o).sort();\n    }\n\n    function _get_pam_sign_input_from_params(params) {\n        var si = \"\";\n        var l = _object_to_key_list_sorted(params);\n\n        for (var i in l) {\n            var k = l[i];\n            si += k + \"=\" + pam_encode(params[k]);\n            if (i != l.length - 1) si += \"&\";\n        }\n        return si;\n    }\n\n    function validate_presence_heartbeat(heartbeat, cur_heartbeat, error) {\n        var err = false;\n\n        if (typeof heartbeat === 'undefined') {\n            return cur_heartbeat;\n        }\n\n        if (typeof heartbeat === 'number') {\n            if (heartbeat > PRESENCE_HB_THRESHOLD || heartbeat == 0) err = false;else err = true;\n        } else if (typeof heartbeat === 'boolean') {\n            if (!heartbeat) {\n                return 0;\n            } else {\n                return PRESENCE_HB_DEFAULT;\n            }\n        } else {\n            err = true;\n        }\n\n        if (err) {\n            error && error(\"Presence Heartbeat value invalid. Valid range ( x > \" + PRESENCE_HB_THRESHOLD + \" or x = 0). Current Value : \" + (cur_heartbeat || PRESENCE_HB_THRESHOLD));\n            return cur_heartbeat || PRESENCE_HB_THRESHOLD;\n        } else return heartbeat;\n    }\n\n    function encrypt(input, key) {\n        return crypto_obj['encrypt'](input, key || CIPHER_KEY) || input;\n    }\n    function decrypt(input, key) {\n        return crypto_obj['decrypt'](input, key || CIPHER_KEY) || crypto_obj['decrypt'](input, CIPHER_KEY) || input;\n    }\n\n    function error_common(message, callback) {\n        callback && callback({ 'error': message || \"error occurred\" });\n        _error && _error(message);\n    }\n    function _presence_heartbeat() {\n\n        clearTimeout(PRESENCE_HB_TIMEOUT);\n\n        if (!PRESENCE_HB_INTERVAL || PRESENCE_HB_INTERVAL >= 500 || PRESENCE_HB_INTERVAL < 1 || !generate_channel_list(CHANNELS, true).length && !generate_channel_group_list(CHANNEL_GROUPS, true).length) {\n            PRESENCE_HB_RUNNING = false;\n            return;\n        }\n\n        PRESENCE_HB_RUNNING = true;\n        SELF['presence_heartbeat']({\n            'callback': function callback(r) {\n                PRESENCE_HB_TIMEOUT = timeout(_presence_heartbeat, PRESENCE_HB_INTERVAL * SECOND);\n            },\n            'error': function error(e) {\n                _error && _error(\"Presence Heartbeat unable to reach Pubnub servers.\" + JSON.stringify(e));\n                PRESENCE_HB_TIMEOUT = timeout(_presence_heartbeat, PRESENCE_HB_INTERVAL * SECOND);\n            }\n        });\n    }\n\n    function start_presence_heartbeat() {\n        !PRESENCE_HB_RUNNING && _presence_heartbeat();\n    }\n\n    function _publish(next) {\n\n        if (NO_WAIT_FOR_PENDING) {\n            if (!PUB_QUEUE.length) return;\n        } else {\n            if (next) PUB_QUEUE.sending = 0;\n            if (PUB_QUEUE.sending || !PUB_QUEUE.length) return;\n            PUB_QUEUE.sending = 1;\n        }\n\n        xdr(PUB_QUEUE.shift());\n    }\n    function each_channel_group(callback) {\n        var count = 0;\n\n        each(generate_channel_group_list(CHANNEL_GROUPS), function (channel_group) {\n            var chang = CHANNEL_GROUPS[channel_group];\n\n            if (!chang) return;\n\n            count++;\n            (callback || function () {})(chang);\n        });\n\n        return count;\n    }\n\n    function each_channel(callback) {\n        var count = 0;\n\n        each(generate_channel_list(CHANNELS), function (channel) {\n            var chan = CHANNELS[channel];\n\n            if (!chan) return;\n\n            count++;\n            (callback || function () {})(chan);\n        });\n\n        return count;\n    }\n    function _invoke_callback(response, callback, err) {\n        if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) == 'object') {\n            if (response['error']) {\n                var callback_data = {};\n\n                if (response['message']) {\n                    callback_data['message'] = response['message'];\n                }\n\n                if (response['payload']) {\n                    callback_data['payload'] = response['payload'];\n                }\n\n                err && err(callback_data);\n                return;\n            }\n            if (response['payload']) {\n                if (response['next_page']) callback && callback(response['payload'], response['next_page']);else callback && callback(response['payload']);\n                return;\n            }\n        }\n        callback && callback(response);\n    }\n\n    function _invoke_error(response, err) {\n\n        if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) == 'object' && response['error']) {\n            var callback_data = {};\n\n            if (response['message']) {\n                callback_data['message'] = response['message'];\n            }\n\n            if (response['payload']) {\n                callback_data['payload'] = response['payload'];\n            }\n\n            err && err(callback_data);\n            return;\n        } else {\n            err && err(response);\n        }\n    }\n    function CR(args, callback, url1, data) {\n        var callback = args['callback'] || callback,\n            err = args['error'] || _error,\n            jsonp = jsonp_cb();\n\n        data = data || {};\n\n        if (!data['auth']) {\n            data['auth'] = args['auth_key'] || AUTH_KEY;\n        }\n\n        var url = [STD_ORIGIN, 'v1', 'channel-registration', 'sub-key', SUBSCRIBE_KEY];\n\n        url.push.apply(url, url1);\n\n        if (jsonp) data['callback'] = jsonp;\n\n        xdr({\n            callback: jsonp,\n            data: _get_url_params(data),\n            success: function success(response) {\n                _invoke_callback(response, callback, err);\n            },\n            fail: function fail(response) {\n                _invoke_error(response, err);\n            },\n            url: url\n        });\n    }\n\n    // Announce Leave Event\n    var SELF = {\n        'LEAVE': function LEAVE(channel, blocking, auth_key, callback, error) {\n\n            var data = { 'uuid': UUID, 'auth': auth_key || AUTH_KEY },\n                origin = nextorigin(ORIGIN),\n                callback = callback || function () {},\n                err = error || function () {},\n                url,\n                params,\n                jsonp = jsonp_cb();\n\n            // Prevent Leaving a Presence Channel\n            if (channel.indexOf(PRESENCE_SUFFIX) > 0) return true;\n\n            if (COMPATIBLE_35) {\n                if (!SSL) return false;\n                if (jsonp == '0') return false;\n            }\n\n            if (NOLEAVE) return false;\n\n            if (jsonp != '0') data['callback'] = jsonp;\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            url = [origin, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY, 'channel', encode(channel), 'leave'];\n\n            params = _get_url_params(data);\n\n            if (sendBeacon) {\n                url_string = build_url(url, params);\n                if (sendBeacon(url_string)) {\n                    callback && callback({ \"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\" });\n                    return true;\n                }\n            }\n\n            xdr({\n                blocking: blocking || SSL,\n                timeout: 2000,\n                callback: jsonp,\n                data: params,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n            });\n            return true;\n        },\n        'LEAVE_GROUP': function LEAVE_GROUP(channel_group, blocking, auth_key, callback, error) {\n\n            var data = { 'uuid': UUID, 'auth': auth_key || AUTH_KEY },\n                origin = nextorigin(ORIGIN),\n                url,\n                params,\n                callback = callback || function () {},\n                err = error || function () {},\n                jsonp = jsonp_cb();\n\n            // Prevent Leaving a Presence Channel Group\n            if (channel_group.indexOf(PRESENCE_SUFFIX) > 0) return true;\n\n            if (COMPATIBLE_35) {\n                if (!SSL) return false;\n                if (jsonp == '0') return false;\n            }\n\n            if (NOLEAVE) return false;\n\n            if (jsonp != '0') data['callback'] = jsonp;\n\n            if (channel_group && channel_group.length > 0) data['channel-group'] = channel_group;\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            url = [origin, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY, 'channel', encode(','), 'leave'];\n\n            params = _get_url_params(data);\n\n            if (sendBeacon) {\n                url_string = build_url(url, params);\n                if (sendBeacon(url_string)) {\n                    callback && callback({ \"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\" });\n                    return true;\n                }\n            }\n\n            xdr({\n                blocking: blocking || SSL,\n                timeout: 5000,\n                callback: jsonp,\n                data: params,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n            });\n            return true;\n        },\n        'set_resumed': function set_resumed(resumed) {\n            RESUMED = resumed;\n        },\n        'get_cipher_key': function get_cipher_key() {\n            return CIPHER_KEY;\n        },\n        'set_cipher_key': function set_cipher_key(key) {\n            CIPHER_KEY = key;\n        },\n        'raw_encrypt': function raw_encrypt(input, key) {\n            return encrypt(input, key);\n        },\n        'raw_decrypt': function raw_decrypt(input, key) {\n            return decrypt(input, key);\n        },\n        'get_heartbeat': function get_heartbeat() {\n            return PRESENCE_HB;\n        },\n\n        'set_heartbeat': function set_heartbeat(heartbeat, heartbeat_interval) {\n            PRESENCE_HB = validate_presence_heartbeat(heartbeat, PRESENCE_HB, _error);\n            PRESENCE_HB_INTERVAL = heartbeat_interval || PRESENCE_HB / 2 - 1;\n            if (PRESENCE_HB == 2) {\n                PRESENCE_HB_INTERVAL = 1;\n            }\n            CONNECT();\n            _presence_heartbeat();\n        },\n\n        'get_heartbeat_interval': function get_heartbeat_interval() {\n            return PRESENCE_HB_INTERVAL;\n        },\n\n        'set_heartbeat_interval': function set_heartbeat_interval(heartbeat_interval) {\n            PRESENCE_HB_INTERVAL = heartbeat_interval;\n            _presence_heartbeat();\n        },\n\n        'get_version': function get_version() {\n            return SDK_VER;\n        },\n        'getGcmMessageObject': function getGcmMessageObject(obj) {\n            return {\n                'data': obj\n            };\n        },\n        'getApnsMessageObject': function getApnsMessageObject(obj) {\n            var x = {\n                'aps': { 'badge': 1, 'alert': '' }\n            };\n            for (k in obj) {\n                k[x] = obj[k];\n            }\n            return x;\n        },\n        'newPnMessage': function newPnMessage() {\n            var x = {};\n            if (gcm) x['pn_gcm'] = gcm;\n            if (apns) x['pn_apns'] = apns;\n            for (k in n) {\n                x[k] = n[k];\n            }\n            return x;\n        },\n\n        '_add_param': function _add_param(key, val) {\n            params[key] = val;\n        },\n\n        'channel_group': function channel_group(args, callback) {\n            var ns_ch = args['channel_group'],\n                callback = callback || args['callback'],\n                channels = args['channels'] || args['channel'],\n                cloak = args['cloak'],\n                namespace,\n                channel_group,\n                url = [],\n                data = {},\n                mode = args['mode'] || 'add';\n\n            if (ns_ch) {\n                var ns_ch_a = ns_ch.split(':');\n\n                if (ns_ch_a.length > 1) {\n                    namespace = ns_ch_a[0] === '*' ? null : ns_ch_a[0];\n\n                    channel_group = ns_ch_a[1];\n                } else {\n                    channel_group = ns_ch_a[0];\n                }\n            }\n\n            namespace && url.push('namespace') && url.push(encode(namespace));\n\n            url.push('channel-group');\n\n            if (channel_group && channel_group !== '*') {\n                url.push(channel_group);\n            }\n\n            if (channels) {\n                if (isArray(channels)) {\n                    channels = channels.join(',');\n                }\n                data[mode] = channels;\n                data['cloak'] = CLOAK ? 'true' : 'false';\n            } else {\n                if (mode === 'remove') url.push('remove');\n            }\n\n            if (typeof cloak != 'undefined') data['cloak'] = cloak ? 'true' : 'false';\n\n            CR(args, callback, url, data);\n        },\n\n        'channel_group_list_groups': function channel_group_list_groups(args, callback) {\n            var namespace;\n\n            namespace = args['namespace'] || args['ns'] || args['channel_group'] || null;\n            if (namespace) {\n                args[\"channel_group\"] = namespace + \":*\";\n            }\n\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_list_channels': function channel_group_list_channels(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_remove_channel': function channel_group_remove_channel(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            if (!args['channel'] && !args['channels']) return _error('Missing Channel');\n\n            args['mode'] = 'remove';\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_remove_group': function channel_group_remove_group(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            if (args['channel']) return _error('Use channel_group_remove_channel if you want to remove a channel from a group.');\n\n            args['mode'] = 'remove';\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_add_channel': function channel_group_add_channel(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            if (!args['channel'] && !args['channels']) return _error('Missing Channel');\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_cloak': function channel_group_cloak(args, callback) {\n            if (typeof args['cloak'] == 'undefined') {\n                callback(CLOAK);\n                return;\n            }\n            CLOAK = args['cloak'];\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_list_namespaces': function channel_group_list_namespaces(args, callback) {\n            var url = ['namespace'];\n            CR(args, callback, url);\n        },\n        'channel_group_remove_namespace': function channel_group_remove_namespace(args, callback) {\n            var url = ['namespace', args['namespace'], 'remove'];\n            CR(args, callback, url);\n        },\n\n        /*\n         PUBNUB.history({\n         channel  : 'my_chat_channel',\n         limit    : 100,\n         callback : function(history) { }\n         });\n         */\n        'history': function history(args, callback) {\n            var callback = args['callback'] || callback,\n                count = args['count'] || args['limit'] || 100,\n                reverse = args['reverse'] || \"false\",\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                cipher_key = args['cipher_key'],\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                start = args['start'],\n                end = args['end'],\n                include_token = args['include_token'],\n                string_msg_token = args['string_message_token'] || false,\n                params = {},\n                jsonp = jsonp_cb();\n\n            // Make sure we have a Channel\n            if (!channel && !channel_group) return _error('Missing Channel');\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            params['stringtoken'] = 'true';\n            params['count'] = count;\n            params['reverse'] = reverse;\n            params['auth'] = auth_key;\n\n            if (channel_group) {\n                params['channel-group'] = channel_group;\n                if (!channel) {\n                    channel = ',';\n                }\n            }\n            if (jsonp) params['callback'] = jsonp;\n            if (start) params['start'] = start;\n            if (end) params['end'] = end;\n            if (include_token) params['include_token'] = 'true';\n            if (string_msg_token) params['string_message_token'] = 'true';\n\n            // Send Message\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(params),\n                success: function success(response) {\n                    if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) == 'object' && response['error']) {\n                        err({ 'message': response['message'], 'payload': response['payload'] });\n                        return;\n                    }\n                    var messages = response[0];\n                    var decrypted_messages = [];\n                    for (var a = 0; a < messages.length; a++) {\n                        if (include_token) {\n                            var new_message = decrypt(messages[a]['message'], cipher_key);\n                            var timetoken = messages[a]['timetoken'];\n                            try {\n                                decrypted_messages['push']({ \"message\": JSON['parse'](new_message), \"timetoken\": timetoken });\n                            } catch (e) {\n                                decrypted_messages['push']({ \"message\": new_message, \"timetoken\": timetoken });\n                            }\n                        } else {\n                            var new_message = decrypt(messages[a], cipher_key);\n                            try {\n                                decrypted_messages['push'](JSON['parse'](new_message));\n                            } catch (e) {\n                                decrypted_messages['push'](new_message);\n                            }\n                        }\n                    }\n                    callback([decrypted_messages, response[1], response[2]]);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v2', 'history', 'sub-key', SUBSCRIBE_KEY, 'channel', encode(channel)]\n            });\n        },\n\n        /*\n         PUBNUB.replay({\n         source      : 'my_channel',\n         destination : 'new_channel'\n         });\n         */\n        'replay': function replay(args, callback) {\n            var callback = callback || args['callback'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                source = args['source'],\n                destination = args['destination'],\n                stop = args['stop'],\n                start = args['start'],\n                end = args['end'],\n                reverse = args['reverse'],\n                limit = args['limit'],\n                jsonp = jsonp_cb(),\n                data = {},\n                url;\n\n            // Check User Input\n            if (!source) return _error('Missing Source Channel');\n            if (!destination) return _error('Missing Destination Channel');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            // Setup URL Params\n            if (jsonp != '0') data['callback'] = jsonp;\n            if (stop) data['stop'] = 'all';\n            if (reverse) data['reverse'] = 'true';\n            if (start) data['start'] = start;\n            if (end) data['end'] = end;\n            if (limit) data['count'] = limit;\n\n            data['auth'] = auth_key;\n\n            // Compose URL Parts\n            url = [STD_ORIGIN, 'v1', 'replay', PUBLISH_KEY, SUBSCRIBE_KEY, source, destination];\n\n            // Start (or Stop) Replay!\n            xdr({\n                callback: jsonp,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail() {\n                    callback([0, 'Disconnected']);\n                },\n                url: url,\n                data: _get_url_params(data)\n            });\n        },\n\n        /*\n         PUBNUB.auth('AJFLKAJSDKLA');\n         */\n        'auth': function auth(_auth) {\n            AUTH_KEY = _auth;\n            CONNECT();\n        },\n\n        /*\n         PUBNUB.time(function(time){ });\n         */\n        'time': function time(callback) {\n            var jsonp = jsonp_cb();\n\n            var data = { 'uuid': UUID, 'auth': AUTH_KEY };\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                timeout: SECOND * 5,\n                url: [STD_ORIGIN, 'time', jsonp],\n                success: function success(response) {\n                    callback(response[0]);\n                },\n                fail: function fail() {\n                    callback(0);\n                }\n            });\n        },\n\n        /*\n         PUBNUB.publish({\n         channel : 'my_chat_channel',\n         message : 'hello!'\n         });\n         */\n        'publish': function publish(args, callback) {\n            var msg = args['message'];\n            if (!msg) return _error('Missing Message');\n\n            var callback = callback || args['callback'] || msg['callback'] || function () {},\n                channel = args['channel'] || msg['channel'],\n                auth_key = args['auth_key'] || AUTH_KEY,\n                cipher_key = args['cipher_key'],\n                err = args['error'] || msg['error'] || function () {},\n                post = args['post'] || false,\n                store = 'store_in_history' in args ? args['store_in_history'] : true,\n                jsonp = jsonp_cb(),\n                add_msg = 'push',\n                params,\n                url;\n\n            if (args['prepend']) add_msg = 'unshift';\n\n            if (!channel) return _error('Missing Channel');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            if (msg['getPubnubMessage']) {\n                msg = msg['getPubnubMessage']();\n            }\n\n            // If trying to send Object\n            msg = JSON['stringify'](encrypt(msg, cipher_key));\n\n            // Create URL\n            url = [STD_ORIGIN, 'publish', PUBLISH_KEY, SUBSCRIBE_KEY, 0, encode(channel), jsonp, encode(msg)];\n\n            params = { 'uuid': UUID, 'auth': auth_key };\n\n            if (!store) params['store'] = \"0\";\n\n            if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;\n\n            // Queue Message Send\n            PUB_QUEUE[add_msg]({\n                callback: jsonp,\n                timeout: SECOND * 5,\n                url: url,\n                data: _get_url_params(params),\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                    _publish(1);\n                },\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                    _publish(1);\n                },\n                mode: post ? 'POST' : 'GET'\n            });\n\n            // Send Message\n            _publish();\n        },\n\n        /*\n         PUBNUB.unsubscribe({ channel : 'my_chat' });\n         */\n        'unsubscribe': function unsubscribe(args, callback) {\n            var channel = args['channel'],\n                channel_group = args['channel_group'],\n                auth_key = args['auth_key'] || AUTH_KEY,\n                callback = callback || args['callback'] || function () {},\n                err = args['error'] || function () {};\n\n            TIMETOKEN = 0;\n            SUB_RESTORE = 1; // REVISIT !!!!\n\n            if (channel) {\n\n                // Prepare LeaveChannel(s)\n                var leave_c = map((channel.join ? channel.join(',') : '' + channel).split(','), function (channel) {\n                    if (!CHANNELS[channel]) return;\n                    return channel;\n                }).join(',');\n\n                // Prepare Channel(s)\n                channel = map((channel.join ? channel.join(',') : '' + channel).split(','), function (channel) {\n                    if (!CHANNELS[channel]) return;\n                    return channel + ',' + channel + PRESENCE_SUFFIX;\n                }).join(',');\n\n                // Iterate over Channels\n                each(channel.split(','), function (ch) {\n                    if (!ch) return;\n                    CHANNELS[ch] = 0;\n                    if (ch in STATE) delete STATE[ch];\n                });\n\n                var CB_CALLED = true;\n                if (READY) {\n                    CB_CALLED = SELF['LEAVE'](leave_c, 0, auth_key, callback, err);\n                }\n                if (!CB_CALLED) callback({ action: \"leave\" });\n            }\n\n            if (channel_group) {\n\n                // Prepare channel group(s)\n                var leave_gc = map((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','), function (channel_group) {\n                    if (!CHANNEL_GROUPS[channel_group]) return;\n                    return channel_group;\n                }).join(',');\n\n                // Prepare channel group(s)\n                channel_group = map((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','), function (channel_group) {\n                    if (!CHANNEL_GROUPS[channel_group]) return;\n                    return channel_group + ',' + channel_group + PRESENCE_SUFFIX;\n                }).join(',');\n\n                // Iterate over channel groups\n                each(channel_group.split(','), function (chg) {\n                    if (!chg) return;\n                    CHANNEL_GROUPS[chg] = 0;\n                    if (chg in STATE) delete STATE[chg];\n                });\n\n                var CB_CALLED = true;\n                if (READY) {\n                    CB_CALLED = SELF['LEAVE_GROUP'](leave_gc, 0, auth_key, callback, err);\n                }\n                if (!CB_CALLED) callback({ action: \"leave\" });\n            }\n\n            // Reset Connection if Count Less\n            CONNECT();\n        },\n\n        /*\n         PUBNUB.subscribe({\n         channel  : 'my_chat'\n         callback : function(message) { }\n         });\n         */\n        'subscribe': function subscribe(args, callback) {\n            var channel = args['channel'],\n                channel_group = args['channel_group'],\n                callback = callback || args['callback'],\n                callback = callback || args['message'],\n                connect = args['connect'] || function () {},\n                reconnect = args['reconnect'] || function () {},\n                disconnect = args['disconnect'] || function () {},\n                SUB_ERROR = args['error'] || SUB_ERROR || function () {},\n                idlecb = args['idle'] || function () {},\n                presence = args['presence'] || 0,\n                noheresync = args['noheresync'] || 0,\n                backfill = args['backfill'] || 0,\n                timetoken = args['timetoken'] || 0,\n                sub_timeout = args['timeout'] || SUB_TIMEOUT,\n                windowing = args['windowing'] || SUB_WINDOWING,\n                state = args['state'],\n                heartbeat = args['heartbeat'] || args['pnexpires'],\n                heartbeat_interval = args['heartbeat_interval'],\n                restore = args['restore'] || SUB_RESTORE;\n\n            AUTH_KEY = args['auth_key'] || AUTH_KEY;\n\n            // Restore Enabled?\n            SUB_RESTORE = restore;\n\n            // Always Reset the TT\n            TIMETOKEN = timetoken;\n\n            // Make sure we have a Channel\n            if (!channel && !channel_group) {\n                return _error('Missing Channel');\n            }\n\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            if (heartbeat || heartbeat === 0 || heartbeat_interval || heartbeat_interval === 0) {\n                SELF['set_heartbeat'](heartbeat, heartbeat_interval);\n            }\n\n            // Setup Channel(s)\n            if (channel) {\n                each((channel.join ? channel.join(',') : '' + channel).split(','), function (channel) {\n                    var settings = CHANNELS[channel] || {};\n\n                    // Store Channel State\n                    CHANNELS[SUB_CHANNEL = channel] = {\n                        name: channel,\n                        connected: settings.connected,\n                        disconnected: settings.disconnected,\n                        subscribed: 1,\n                        callback: SUB_CALLBACK = callback,\n                        'cipher_key': args['cipher_key'],\n                        connect: connect,\n                        disconnect: disconnect,\n                        reconnect: reconnect\n                    };\n\n                    if (state) {\n                        if (channel in state) {\n                            STATE[channel] = state[channel];\n                        } else {\n                            STATE[channel] = state;\n                        }\n                    }\n\n                    // Presence Enabled?\n                    if (!presence) return;\n\n                    // Subscribe Presence Channel\n                    SELF['subscribe']({\n                        'channel': channel + PRESENCE_SUFFIX,\n                        'callback': presence,\n                        'restore': restore\n                    });\n\n                    // Presence Subscribed?\n                    if (settings.subscribed) return;\n\n                    // See Who's Here Now?\n                    if (noheresync) return;\n                    SELF['here_now']({\n                        'channel': channel,\n                        'data': _get_url_params({ 'uuid': UUID, 'auth': AUTH_KEY }),\n                        'callback': function callback(here) {\n                            each('uuids' in here ? here['uuids'] : [], function (uid) {\n                                presence({\n                                    'action': 'join',\n                                    'uuid': uid,\n                                    'timestamp': Math.floor(rnow() / 1000),\n                                    'occupancy': here['occupancy'] || 1\n                                }, here, channel);\n                            });\n                        }\n                    });\n                });\n            }\n\n            // Setup Channel Groups\n            if (channel_group) {\n                each((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','), function (channel_group) {\n                    var settings = CHANNEL_GROUPS[channel_group] || {};\n\n                    CHANNEL_GROUPS[channel_group] = {\n                        name: channel_group,\n                        connected: settings.connected,\n                        disconnected: settings.disconnected,\n                        subscribed: 1,\n                        callback: SUB_CALLBACK = callback,\n                        'cipher_key': args['cipher_key'],\n                        connect: connect,\n                        disconnect: disconnect,\n                        reconnect: reconnect\n                    };\n\n                    // Presence Enabled?\n                    if (!presence) return;\n\n                    // Subscribe Presence Channel\n                    SELF['subscribe']({\n                        'channel_group': channel_group + PRESENCE_SUFFIX,\n                        'callback': presence,\n                        'restore': restore,\n                        'auth_key': AUTH_KEY\n                    });\n\n                    // Presence Subscribed?\n                    if (settings.subscribed) return;\n\n                    // See Who's Here Now?\n                    if (noheresync) return;\n                    SELF['here_now']({\n                        'channel_group': channel_group,\n                        'data': _get_url_params({ 'uuid': UUID, 'auth': AUTH_KEY }),\n                        'callback': function callback(here) {\n                            each('uuids' in here ? here['uuids'] : [], function (uid) {\n                                presence({\n                                    'action': 'join',\n                                    'uuid': uid,\n                                    'timestamp': Math.floor(rnow() / 1000),\n                                    'occupancy': here['occupancy'] || 1\n                                }, here, channel_group);\n                            });\n                        }\n                    });\n                });\n            }\n\n            // Test Network Connection\n            function _test_connection(success) {\n                if (success) {\n                    // Begin Next Socket Connection\n                    timeout(CONNECT, windowing);\n                } else {\n                    // New Origin on Failed Connection\n                    STD_ORIGIN = nextorigin(ORIGIN, 1);\n                    SUB_ORIGIN = nextorigin(ORIGIN, 1);\n\n                    // Re-test Connection\n                    timeout(function () {\n                        SELF['time'](_test_connection);\n                    }, SECOND);\n                }\n\n                // Disconnect & Reconnect\n                each_channel(function (channel) {\n                    // Reconnect\n                    if (success && channel.disconnected) {\n                        channel.disconnected = 0;\n                        return channel.reconnect(channel.name);\n                    }\n\n                    // Disconnect\n                    if (!success && !channel.disconnected) {\n                        channel.disconnected = 1;\n                        channel.disconnect(channel.name);\n                    }\n                });\n\n                // Disconnect & Reconnect for channel groups\n                each_channel_group(function (channel_group) {\n                    // Reconnect\n                    if (success && channel_group.disconnected) {\n                        channel_group.disconnected = 0;\n                        return channel_group.reconnect(channel_group.name);\n                    }\n\n                    // Disconnect\n                    if (!success && !channel_group.disconnected) {\n                        channel_group.disconnected = 1;\n                        channel_group.disconnect(channel_group.name);\n                    }\n                });\n            }\n\n            // Evented Subscribe\n            function _connect() {\n                var jsonp = jsonp_cb(),\n                    channels = generate_channel_list(CHANNELS).join(','),\n                    channel_groups = generate_channel_group_list(CHANNEL_GROUPS).join(',');\n\n                // Stop Connection\n                if (!channels && !channel_groups) return;\n\n                if (!channels) channels = ',';\n\n                // Connect to PubNub Subscribe Servers\n                _reset_offline();\n\n                var data = _get_url_params({ 'uuid': UUID, 'auth': AUTH_KEY });\n\n                if (channel_groups) {\n                    data['channel-group'] = channel_groups;\n                }\n\n                var st = JSON.stringify(STATE);\n                if (st.length > 2) data['state'] = JSON.stringify(STATE);\n\n                if (PRESENCE_HB) data['heartbeat'] = PRESENCE_HB;\n\n                if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n                start_presence_heartbeat();\n                SUB_RECEIVER = xdr({\n                    timeout: sub_timeout,\n                    callback: jsonp,\n                    fail: function fail(response) {\n                        if (response && response['error'] && response['service']) {\n                            _invoke_error(response, SUB_ERROR);\n                            _test_connection(1);\n                        } else {\n                            SELF['time'](function (success) {\n                                !success && _invoke_error(response, SUB_ERROR);\n                                _test_connection(success);\n                            });\n                        }\n                    },\n                    data: _get_url_params(data),\n                    url: [SUB_ORIGIN, 'subscribe', SUBSCRIBE_KEY, encode(channels), jsonp, TIMETOKEN],\n                    success: function success(messages) {\n\n                        // Check for Errors\n                        if (!messages || (typeof messages === 'undefined' ? 'undefined' : _typeof(messages)) == 'object' && 'error' in messages && messages['error']) {\n                            SUB_ERROR(messages['error']);\n                            return timeout(CONNECT, SECOND);\n                        }\n\n                        // User Idle Callback\n                        idlecb(messages[1]);\n\n                        // Restore Previous Connection Point if Needed\n                        TIMETOKEN = !TIMETOKEN && SUB_RESTORE && db['get'](SUBSCRIBE_KEY) || messages[1];\n\n                        /*\n                         // Connect\n                         each_channel_registry(function(registry){\n                         if (registry.connected) return;\n                         registry.connected = 1;\n                         registry.connect(channel.name);\n                         });\n                         */\n\n                        // Connect\n                        each_channel(function (channel) {\n                            if (channel.connected) return;\n                            channel.connected = 1;\n                            channel.connect(channel.name);\n                        });\n\n                        // Connect for channel groups\n                        each_channel_group(function (channel_group) {\n                            if (channel_group.connected) return;\n                            channel_group.connected = 1;\n                            channel_group.connect(channel_group.name);\n                        });\n\n                        if (RESUMED && !SUB_RESTORE) {\n                            TIMETOKEN = 0;\n                            RESUMED = false;\n                            // Update Saved Timetoken\n                            db['set'](SUBSCRIBE_KEY, 0);\n                            timeout(_connect, windowing);\n                            return;\n                        }\n\n                        // Invoke Memory Catchup and Receive Up to 100\n                        // Previous Messages from the Queue.\n                        if (backfill) {\n                            TIMETOKEN = 10000;\n                            backfill = 0;\n                        }\n\n                        // Update Saved Timetoken\n                        db['set'](SUBSCRIBE_KEY, messages[1]);\n\n                        // Route Channel <---> Callback for Message\n                        var next_callback = (function () {\n                            var channels = '';\n                            var channels2 = '';\n\n                            if (messages.length > 3) {\n                                channels = messages[3];\n                                channels2 = messages[2];\n                            } else if (messages.length > 2) {\n                                channels = messages[2];\n                            } else {\n                                channels = map(generate_channel_list(CHANNELS), function (chan) {\n                                    return map(Array(messages[0].length).join(',').split(','), function () {\n                                        return chan;\n                                    });\n                                }).join(',');\n                            }\n\n                            var list = channels.split(',');\n                            var list2 = channels2 ? channels2.split(',') : [];\n\n                            return function () {\n                                var channel = list.shift() || SUB_CHANNEL;\n                                var channel2 = list2.shift();\n\n                                var chobj = {};\n\n                                if (channel2) {\n                                    if (channel && channel.indexOf('-pnpres') >= 0 && channel2.indexOf('-pnpres') < 0) {\n                                        channel2 += '-pnpres';\n                                    }\n                                    chobj = CHANNEL_GROUPS[channel2] || CHANNELS[channel2] || { 'callback': function callback() {} };\n                                } else {\n                                    chobj = CHANNELS[channel];\n                                }\n\n                                var r = [chobj.callback || SUB_CALLBACK, channel.split(PRESENCE_SUFFIX)[0]];\n                                channel2 && r.push(channel2.split(PRESENCE_SUFFIX)[0]);\n                                return r;\n                            };\n                        })();\n\n                        var latency = detect_latency(+messages[1]);\n                        each(messages[0], function (msg) {\n                            var next = next_callback();\n                            var decrypted_msg = decrypt(msg, CHANNELS[next[1]] ? CHANNELS[next[1]]['cipher_key'] : null);\n                            next[0] && next[0](decrypted_msg, messages, next[2] || next[1], latency, next[1]);\n                        });\n\n                        timeout(_connect, windowing);\n                    }\n                });\n            }\n\n            CONNECT = function () {\n                _reset_offline();\n                timeout(_connect, windowing);\n            };\n\n            // Reduce Status Flicker\n            if (!READY) return READY_BUFFER.push(CONNECT);\n\n            // Connect Now\n            CONNECT();\n        },\n\n        /*\n         PUBNUB.here_now({ channel : 'my_chat', callback : fun });\n         */\n        'here_now': function here_now(args, callback) {\n            var callback = args['callback'] || callback,\n                debug = args['debug'],\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                jsonp = jsonp_cb(),\n                uuids = 'uuids' in args ? args['uuids'] : true,\n                state = args['state'],\n                data = { 'uuid': UUID, 'auth': auth_key };\n\n            if (!uuids) data['disable_uuids'] = 1;\n            if (state) data['state'] = 1;\n\n            // Make sure we have a Channel\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            var url = [STD_ORIGIN, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY];\n\n            channel && url.push('channel') && url.push(encode(channel));\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            if (channel_group) {\n                data['channel-group'] = channel_group;\n                !channel && url.push('channel') && url.push(',');\n            }\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                debug: debug,\n                url: url\n            });\n        },\n\n        /*\n         PUBNUB.current_channels_by_uuid({ channel : 'my_chat', callback : fun });\n         */\n        'where_now': function where_now(args, callback) {\n            var callback = args['callback'] || callback,\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                jsonp = jsonp_cb(),\n                uuid = args['uuid'] || UUID,\n                data = { 'auth': auth_key };\n\n            // Make sure we have a Channel\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY, 'uuid', encode(uuid)]\n            });\n        },\n\n        'state': function state(args, callback) {\n            var callback = args['callback'] || callback || function (r) {},\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                jsonp = jsonp_cb(),\n                state = args['state'],\n                uuid = args['uuid'] || UUID,\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                url,\n                data = _get_url_params({ 'auth': auth_key });\n\n            // Make sure we have a Channel\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n            if (!uuid) return _error('Missing UUID');\n            if (!channel && !channel_group) return _error('Missing Channel');\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            if (typeof channel != 'undefined' && CHANNELS[channel] && CHANNELS[channel].subscribed) {\n                if (state) STATE[channel] = state;\n            }\n\n            if (typeof channel_group != 'undefined' && CHANNEL_GROUPS[channel_group] && CHANNEL_GROUPS[channel_group].subscribed) {\n                if (state) STATE[channel_group] = state;\n                data['channel-group'] = channel_group;\n\n                if (!channel) {\n                    channel = ',';\n                }\n            }\n\n            data['state'] = JSON.stringify(state);\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            if (state) {\n                url = [STD_ORIGIN, 'v2', 'presence', 'sub-key', SUBSCRIBE_KEY, 'channel', channel, 'uuid', uuid, 'data'];\n            } else {\n                url = [STD_ORIGIN, 'v2', 'presence', 'sub-key', SUBSCRIBE_KEY, 'channel', channel, 'uuid', encode(uuid)];\n            }\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n\n            });\n        },\n\n        /*\n         PUBNUB.grant({\n         channel  : 'my_chat',\n         callback : fun,\n         error    : fun,\n         ttl      : 24 * 60, // Minutes\n         read     : true,\n         write    : true,\n         auth_key : '3y8uiajdklytowsj'\n         });\n         */\n        'grant': function grant(args, callback) {\n            var callback = args['callback'] || callback,\n                err = args['error'] || function () {},\n                channel = args['channel'] || args['channels'],\n                channel_group = args['channel_group'],\n                jsonp = jsonp_cb(),\n                ttl = args['ttl'],\n                r = args['read'] ? \"1\" : \"0\",\n                w = args['write'] ? \"1\" : \"0\",\n                m = args['manage'] ? \"1\" : \"0\",\n                auth_key = args['auth_key'] || args['auth_keys'];\n\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SECRET_KEY) return _error('Missing Secret Key');\n\n            var timestamp = Math.floor(new Date().getTime() / 1000),\n                sign_input = SUBSCRIBE_KEY + \"\\n\" + PUBLISH_KEY + \"\\n\" + \"grant\" + \"\\n\";\n\n            var data = {\n                'w': w,\n                'r': r,\n                'timestamp': timestamp\n            };\n            if (args['manage']) {\n                data['m'] = m;\n            }\n            if (isArray(channel)) {\n                channel = channel['join'](',');\n            }\n            if (isArray(auth_key)) {\n                auth_key = auth_key['join'](',');\n            }\n            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n                data['channel-group'] = channel_group;\n            }\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n            if (ttl || ttl === 0) data['ttl'] = ttl;\n\n            if (auth_key) data['auth'] = auth_key;\n\n            data = _get_url_params(data);\n\n            if (!auth_key) delete data['auth'];\n\n            sign_input += _get_pam_sign_input_from_params(data);\n\n            var signature = hmac_SHA256(sign_input, SECRET_KEY);\n\n            signature = signature.replace(/\\+/g, \"-\");\n            signature = signature.replace(/\\//g, \"_\");\n\n            data['signature'] = signature;\n\n            xdr({\n                callback: jsonp,\n                data: data,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v1', 'auth', 'grant', 'sub-key', SUBSCRIBE_KEY]\n            });\n        },\n\n        /*\n         PUBNUB.mobile_gw_provision ({\n         device_id: 'A655FBA9931AB',\n         op       : 'add' | 'remove',\n         gw_type  : 'apns' | 'gcm',\n         channel  : 'my_chat',\n         callback : fun,\n         error    : fun,\n         });\n         */\n\n        'mobile_gw_provision': function mobile_gw_provision(args) {\n\n            var callback = args['callback'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                err = args['error'] || function () {},\n                jsonp = jsonp_cb(),\n                channel = args['channel'],\n                op = args['op'],\n                gw_type = args['gw_type'],\n                device_id = args['device_id'],\n                params,\n                url;\n\n            if (!device_id) return _error('Missing Device ID (device_id)');\n            if (!gw_type) return _error('Missing GW Type (gw_type: gcm or apns)');\n            if (!op) return _error('Missing GW Operation (op: add or remove)');\n            if (!channel) return _error('Missing gw destination Channel (channel)');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            // Create URL\n            url = [STD_ORIGIN, 'v1/push/sub-key', SUBSCRIBE_KEY, 'devices', device_id];\n\n            params = { 'uuid': UUID, 'auth': auth_key, 'type': gw_type };\n\n            if (op == \"add\") {\n                params['add'] = channel;\n            } else if (op == \"remove\") {\n                params['remove'] = channel;\n            }\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: params,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n            });\n        },\n\n        /*\n         PUBNUB.audit({\n         channel  : 'my_chat',\n         callback : fun,\n         error    : fun,\n         read     : true,\n         write    : true,\n         auth_key : '3y8uiajdklytowsj'\n         });\n         */\n        'audit': function audit(args, callback) {\n            var callback = args['callback'] || callback,\n                err = args['error'] || function () {},\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                auth_key = args['auth_key'],\n                jsonp = jsonp_cb();\n\n            // Make sure we have a Channel\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SECRET_KEY) return _error('Missing Secret Key');\n\n            var timestamp = Math.floor(new Date().getTime() / 1000),\n                sign_input = SUBSCRIBE_KEY + \"\\n\" + PUBLISH_KEY + \"\\n\" + \"audit\" + \"\\n\";\n\n            var data = { 'timestamp': timestamp };\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n                data['channel-group'] = channel_group;\n            }\n            if (auth_key) data['auth'] = auth_key;\n\n            data = _get_url_params(data);\n\n            if (!auth_key) delete data['auth'];\n\n            sign_input += _get_pam_sign_input_from_params(data);\n\n            var signature = hmac_SHA256(sign_input, SECRET_KEY);\n\n            signature = signature.replace(/\\+/g, \"-\");\n            signature = signature.replace(/\\//g, \"_\");\n\n            data['signature'] = signature;\n            xdr({\n                callback: jsonp,\n                data: data,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v1', 'auth', 'audit', 'sub-key', SUBSCRIBE_KEY]\n            });\n        },\n\n        /*\n         PUBNUB.revoke({\n         channel  : 'my_chat',\n         callback : fun,\n         error    : fun,\n         auth_key : '3y8uiajdklytowsj'\n         });\n         */\n        'revoke': function revoke(args, callback) {\n            args['read'] = false;\n            args['write'] = false;\n            SELF['grant'](args, callback);\n        },\n        'set_uuid': function set_uuid(uuid) {\n            UUID = uuid;\n            CONNECT();\n        },\n        'get_uuid': function get_uuid() {\n            return UUID;\n        },\n        'isArray': (function (_isArray) {\n            function isArray(_x) {\n                return _isArray.apply(this, arguments);\n            }\n\n            isArray.toString = function () {\n                return _isArray.toString();\n            };\n\n            return isArray;\n        })(function (arg) {\n            return isArray(arg);\n        }),\n        'get_subscibed_channels': function get_subscibed_channels() {\n            return generate_channel_list(CHANNELS, true);\n        },\n        'presence_heartbeat': function presence_heartbeat(args) {\n            var callback = args['callback'] || function () {};\n            var err = args['error'] || function () {};\n            var jsonp = jsonp_cb();\n            var data = { 'uuid': UUID, 'auth': AUTH_KEY };\n\n            var st = JSON['stringify'](STATE);\n            if (st.length > 2) data['state'] = JSON['stringify'](STATE);\n\n            if (PRESENCE_HB > 0 && PRESENCE_HB < 320) data['heartbeat'] = PRESENCE_HB;\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            var channels = encode(generate_channel_list(CHANNELS, true)['join'](','));\n            var channel_groups = generate_channel_group_list(CHANNEL_GROUPS, true)['join'](',');\n\n            if (!channels) channels = ',';\n            if (channel_groups) data['channel-group'] = channel_groups;\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                timeout: SECOND * 5,\n                url: [STD_ORIGIN, 'v2', 'presence', 'sub-key', SUBSCRIBE_KEY, 'channel', channels, 'heartbeat'],\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                }\n            });\n        },\n        'stop_timers': function stop_timers() {\n            clearTimeout(_poll_timer);\n            clearTimeout(_poll_timer2);\n            clearTimeout(PRESENCE_HB_TIMEOUT);\n        },\n        'shutdown': function shutdown() {\n            SELF['stop_timers']();\n            _shutdown && _shutdown();\n        },\n\n        // Expose PUBNUB Functions\n        'xdr': xdr,\n        'ready': ready,\n        'db': db,\n        'uuid': generate_uuid,\n        'map': map,\n        'each': each,\n        'each-channel': each_channel,\n        'grep': grep,\n        'offline': function offline() {\n            _reset_offline(1, { \"message\": \"Offline. Please check your network settings.\" });\n        },\n        'supplant': supplant,\n        'now': rnow,\n        'unique': unique,\n        'updater': updater\n    };\n\n    function _poll_online() {\n        _is_online() || _reset_offline(1, {\n            \"error\": \"Offline. Please check your network settings. \"\n        });\n        _poll_timer && clearTimeout(_poll_timer);\n        _poll_timer = timeout(_poll_online, SECOND);\n    }\n\n    function _poll_online2() {\n        if (!TIME_CHECK) return;\n        SELF['time'](function (success) {\n            detect_time_detla(function () {}, success);\n            success || _reset_offline(1, {\n                \"error\": \"Heartbeat failed to connect to Pubnub Servers.\" + \"Please check your network settings.\"\n            });\n            _poll_timer2 && clearTimeout(_poll_timer2);\n            _poll_timer2 = timeout(_poll_online2, KEEPALIVE);\n        });\n    }\n\n    function _reset_offline(err, msg) {\n        SUB_RECEIVER && SUB_RECEIVER(err, msg);\n        SUB_RECEIVER = null;\n\n        clearTimeout(_poll_timer);\n        clearTimeout(_poll_timer2);\n    }\n\n    if (!UUID) UUID = SELF['uuid']();\n    if (!INSTANCEID) INSTANCEID = SELF['uuid']();\n    db['set'](SUBSCRIBE_KEY + 'uuid', UUID);\n\n    _poll_timer = timeout(_poll_online, SECOND);\n    _poll_timer2 = timeout(_poll_online2, KEEPALIVE);\n    PRESENCE_HB_TIMEOUT = timeout(start_presence_heartbeat, (PRESENCE_HB_INTERVAL - 3) * SECOND);\n\n    // Detect Age of Message\n    function detect_latency(tt) {\n        var adjusted_time = rnow() - TIME_DRIFT;\n        return adjusted_time - tt / 10000;\n    }\n\n    detect_time_detla();\n    function detect_time_detla(cb, time) {\n        var stime = rnow();\n\n        time && calculate(time) || SELF['time'](calculate);\n\n        function calculate(time) {\n            if (!time) return;\n            var ptime = time / 10000,\n                latency = (rnow() - stime) / 2;\n            TIME_DRIFT = rnow() - (ptime + latency);\n            cb && cb(TIME_DRIFT);\n        }\n    }\n\n    return SELF;\n}\n},{\"../package.json\":2}],2:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"reworked_core\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"babel-preset-es2015\": \"^6.3.13\",\n    \"browserify\": \"^12.0.1\",\n    \"gulp\": \"^3.9.0\",\n    \"gulp-babel\": \"^6.1.1\",\n    \"gulp-rename\": \"^1.2.2\",\n    \"gulp-sourcemaps\": \"^1.6.0\",\n    \"gulp-uglify\": \"^1.5.1\",\n    \"gulp-util\": \"^3.0.7\",\n    \"run-sequence\": \"^1.1.5\",\n    \"vinyl-buffer\": \"^1.0.0\",\n    \"vinyl-source-stream\": \"^1.1.0\"\n  },\n  \"dependencies\": {\n    \"underscore\": \"^1.8.3\"\n  }\n}\n\n},{}]},{},[1])\n\n","module.exports={\n  \"name\": \"reworked_core\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"babel-preset-es2015\": \"^6.3.13\",\n    \"browserify\": \"^12.0.1\",\n    \"gulp\": \"^3.9.0\",\n    \"gulp-babel\": \"^6.1.1\",\n    \"gulp-rename\": \"^1.2.2\",\n    \"gulp-sourcemaps\": \"^1.6.0\",\n    \"gulp-uglify\": \"^1.5.1\",\n    \"gulp-util\": \"^3.0.7\",\n    \"run-sequence\": \"^1.1.5\",\n    \"vinyl-buffer\": \"^1.0.0\",\n    \"vinyl-source-stream\": \"^1.1.0\"\n  },\n  \"dependencies\": {\n    \"underscore\": \"^1.8.3\"\n  }\n}\n"],"sourceRoot":"/source/"}