{"version":3,"sources":["node_modules/browser-pack/_prelude.js","lib/pubnub-common.js","pubnub.js","lib/utils.js","node_modules/lodash/collection/forEach.js","node_modules/lodash/internal/arrayEach.js","node_modules/lodash/internal/baseEach.js","node_modules/lodash/internal/baseFor.js","node_modules/lodash/internal/baseForOwn.js","node_modules/lodash/internal/baseProperty.js","node_modules/lodash/internal/bindCallback.js","node_modules/lodash/internal/createBaseEach.js","node_modules/lodash/internal/createBaseFor.js","node_modules/lodash/internal/createForEach.js","node_modules/lodash/internal/getLength.js","node_modules/lodash/internal/getNative.js","node_modules/lodash/internal/isArrayLike.js","node_modules/lodash/internal/isIndex.js","node_modules/lodash/internal/isLength.js","node_modules/lodash/internal/isObjectLike.js","node_modules/lodash/internal/shimKeys.js","node_modules/lodash/internal/toObject.js","node_modules/lodash/lang/isArguments.js","node_modules/lodash/lang/isArray.js","node_modules/lodash/lang/isFunction.js","node_modules/lodash/lang/isNative.js","node_modules/lodash/lang/isObject.js","node_modules/lodash/object/keys.js","node_modules/lodash/object/keysIn.js","node_modules/lodash/utility/identity.js","node_modules/uuid/rng-browser.js","node_modules/uuid/uuid.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","_utils","VERSION","./utils",2,"_interopRequireDefault","default","_typeof","Symbol","constructor","encode","path","encodeURIComponent","unique","NOW","Date","rnow","generateUUID","callback","uuid","v4","updater","fun","rate","runnit","last","clearTimeout","timeout","setTimeout","buildURL","urlComponents","urlParams","url","join","URLBIT","params","_forEach2","value","valueStr","JSON","stringify","push","PARAMSBIT","supplant","str","values","replace","REPL","_","match","sugarTimeout","wait","nextOrigin","origin","failOver","indexOf","selectedOrigin","undefined","chosenOrigin","maxOrigin","defineProperty","_uuid","_forEach","Math","floor","random","lodash/collection/forEach",3,"arrayEach","baseEach","createForEach","forEach","../internal/arrayEach","../internal/baseEach","../internal/createForEach",4,"array","iteratee","index",5,"baseForOwn","createBaseEach","./baseForOwn","./createBaseEach",6,"createBaseFor","baseFor","./createBaseFor",7,"object","keys","../object/keys","./baseFor",8,"baseProperty",9,"bindCallback","func","thisArg","argCount","identity","collection","accumulator","other","source","apply","arguments","../utility/identity",10,"eachFunc","fromRight","getLength","isLength","iterable","toObject","./getLength","./isLength","./toObject",11,"keysFunc","props",12,"arrayFunc","isArray","../lang/isArray","./bindCallback",13,"./baseProperty",14,"getNative","isNative","../lang/isNative",15,"isArrayLike",16,"isIndex","reIsUint","test","MAX_SAFE_INTEGER",17,18,"isObjectLike",19,"shimKeys","keysIn","propsLength","allowIndexes","isArguments","result","objectProto","../lang/isArguments","../object/keysIn","./isIndex",20,"isObject","../lang/isObject",21,"propertyIsEnumerable","../internal/isArrayLike","../internal/isObjectLike",22,"arrayTag","objToString","toString","nativeIsArray","Array","../internal/getNative","../internal/isLength",23,"isFunction","funcTag","./isObject",24,"reIsNative","fnToString","reIsHostCtor","Function","RegExp","./isFunction",25,"type",26,"nativeKeys","Ctor","../internal/shimKeys",27,"isProto","skipIndexes","../internal/isIndex",28,29,"global","rng","crypto","getRandomValues","_rnds8","Uint8Array","_rnds","this","self","window",30,"parse","buf","offset","ii","toLowerCase","oct","_hexToByte","unparse","bth","_byteToHex","v1","options","b","clockseq","_clockseq","msecs","getTime","nsecs","_lastNSecs","dt","_lastMSecs","tl","tmh","node","_nodeId","rnds","_rng","substr","_seedBytes","./rng"],"mappings":"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","file":"pubnub.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar _utils = require('./utils');\n\nvar pubNubUtils = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _typeof(obj) { return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }\n\nvar NOW = 1,\n    READY = false,\n    READY_BUFFER = [],\n    PRESENCE_SUFFIX = '-pnpres',\n    DEF_WINDOWING = 10 // MILLISECONDS.\n,\n    DEF_TIMEOUT = 15000 // MILLISECONDS.\n,\n    DEF_SUB_TIMEOUT = 310 // SECONDS.\n,\n    DEF_KEEPALIVE = 60 // SECONDS (FOR TIMESYNC).\n,\n    SECOND = 1000 // A THOUSAND MILLISECONDS.\n,\n    PRESENCE_HB_THRESHOLD = 5,\n    PRESENCE_HB_DEFAULT = 30,\n    SDK_VER = VERSION;\n\nfunction pam_encode(str) {\n    return encodeURIComponent(str).replace(/[!'()*~]/g, function (c) {\n        return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n    });\n}\n\n/**\n * Generate Subscription Channel List\n * ==================================\n * generate_channel_list(channels_object);\n */\nfunction generate_channel_list(channels, nopresence) {\n    var list = [];\n    each(channels, function (channel, status) {\n        if (nopresence) {\n            if (channel.search('-pnpres') < 0) {\n                if (status.subscribed) list.push(channel);\n            }\n        } else {\n            if (status.subscribed) list.push(channel);\n        }\n    });\n    return list.sort();\n}\n\n/**\n * Generate Subscription Channel Groups List\n * ==================================\n * generate_channel_group_list(channels_groups object);\n */\nfunction generate_channel_group_list(channel_groups, nopresence) {\n    var list = [];\n    each(channel_groups, function (channel_group, status) {\n        if (nopresence) {\n            if (channel_group.search('-pnpres') < 0) {\n                if (status.subscribed) list.push(channel_group);\n            }\n        } else {\n            if (status.subscribed) list.push(channel_group);\n        }\n    });\n    return list.sort();\n}\n\n// PUBNUB READY TO CONNECT\nfunction ready() {\n    timeout(function () {\n        if (READY) return;\n        READY = 1;\n        each(READY_BUFFER, function (connect) {\n            connect();\n        });\n    }, SECOND);\n}\n\nfunction PNmessage(args) {\n    msg = args || { 'apns': {} }, msg['getPubnubMessage'] = function () {\n        var m = {};\n\n        if (Object.keys(msg['apns']).length) {\n            m['pn_apns'] = {\n                'aps': {\n                    'alert': msg['apns']['alert'],\n                    'badge': msg['apns']['badge']\n                }\n            };\n            for (var k in msg['apns']) {\n                m['pn_apns'][k] = msg['apns'][k];\n            }\n            var exclude1 = ['badge', 'alert'];\n            for (var k in exclude1) {\n                delete m['pn_apns'][exclude1[k]];\n            }\n        }\n\n        if (msg['gcm']) {\n            m['pn_gcm'] = {\n                'data': msg['gcm']\n            };\n        }\n\n        for (var k in msg) {\n            m[k] = msg[k];\n        }\n        var exclude = ['apns', 'gcm', 'publish', 'channel', 'callback', 'error'];\n        for (var k in exclude) {\n            delete m[exclude[k]];\n        }\n\n        return m;\n    };\n    msg['publish'] = function () {\n\n        var m = msg.getPubnubMessage();\n\n        if (msg['pubnub'] && msg['channel']) {\n            msg['pubnub'].publish({\n                'message': m,\n                'channel': msg['channel'],\n                'callback': msg['callback'],\n                'error': msg['error']\n            });\n        }\n    };\n    return msg;\n}\n\nfunction PN_API(setup) {\n    var SUB_WINDOWING = +setup['windowing'] || DEF_WINDOWING,\n        SUB_TIMEOUT = (+setup['timeout'] || DEF_SUB_TIMEOUT) * SECOND,\n        KEEPALIVE = (+setup['keepalive'] || DEF_KEEPALIVE) * SECOND,\n        TIME_CHECK = setup['timecheck'] || 0,\n        NOLEAVE = setup['noleave'] || 0,\n        PUBLISH_KEY = setup['publish_key'],\n        SUBSCRIBE_KEY = setup['subscribe_key'],\n        AUTH_KEY = setup['auth_key'] || '',\n        SECRET_KEY = setup['secret_key'] || '',\n        hmac_SHA256 = setup['hmac_SHA256'],\n        SSL = setup['ssl'] ? 's' : '',\n        ORIGIN = 'http' + SSL + '://' + (setup['origin'] || 'pubsub.pubnub.com'),\n        STD_ORIGIN = nextorigin(ORIGIN),\n        SUB_ORIGIN = nextorigin(ORIGIN),\n        CONNECT = function CONNECT() {},\n        PUB_QUEUE = [],\n        CLOAK = true,\n        TIME_DRIFT = 0,\n        SUB_CALLBACK = 0,\n        SUB_CHANNEL = 0,\n        SUB_RECEIVER = 0,\n        SUB_RESTORE = setup['restore'] || 0,\n        SUB_BUFF_WAIT = 0,\n        TIMETOKEN = 0,\n        RESUMED = false,\n        CHANNELS = {},\n        CHANNEL_GROUPS = {},\n        SUB_ERROR = function SUB_ERROR() {},\n        STATE = {},\n        PRESENCE_HB_TIMEOUT = null,\n        PRESENCE_HB = validate_presence_heartbeat(setup['heartbeat'] || setup['pnexpires'] || 0, setup['error']),\n        PRESENCE_HB_INTERVAL = setup['heartbeat_interval'] || PRESENCE_HB / 2 - 1,\n        PRESENCE_HB_RUNNING = false,\n        NO_WAIT_FOR_PENDING = setup['no_wait_for_pending'],\n        COMPATIBLE_35 = setup['compatible_3.5'] || false,\n        xdr = setup['xdr'],\n        params = setup['params'] || {},\n        _error = setup['error'] || function () {},\n        _is_online = setup['_is_online'] || function () {\n        return 1;\n    },\n        jsonp_cb = setup['jsonp_cb'] || function () {\n        return 0;\n    },\n        db = setup['db'] || { 'get': function get() {}, 'set': function set() {} },\n        CIPHER_KEY = setup['cipher_key'],\n        UUID = setup['uuid'] || !setup['unique_uuid'] && db && db['get'](SUBSCRIBE_KEY + 'uuid') || '',\n        USE_INSTANCEID = setup['instance_id'] || false,\n        INSTANCEID = '',\n        _shutdown = setup['shutdown'],\n        use_send_beacon = typeof setup['use_send_beacon'] != 'undefined' ? setup['use_send_beacon'] : true,\n        sendBeacon = use_send_beacon ? setup['sendBeacon'] : null,\n        _poll_timer,\n        _poll_timer2;\n\n    if (PRESENCE_HB === 2) PRESENCE_HB_INTERVAL = 1;\n\n    var crypto_obj = setup['crypto_obj'] || {\n        'encrypt': function encrypt(a, key) {\n            return a;\n        },\n        'decrypt': function decrypt(b, key) {\n            return b;\n        }\n    };\n\n    function _get_url_params(data) {\n        if (!data) data = {};\n        each(params, function (key, value) {\n            if (!(key in data)) data[key] = value;\n        });\n        return data;\n    }\n\n    function _object_to_key_list(o) {\n        var l = [];\n        each(o, function (key, value) {\n            l.push(key);\n        });\n        return l;\n    }\n    function _object_to_key_list_sorted(o) {\n        return _object_to_key_list(o).sort();\n    }\n\n    function _get_pam_sign_input_from_params(params) {\n        var si = \"\";\n        var l = _object_to_key_list_sorted(params);\n\n        for (var i in l) {\n            var k = l[i];\n            si += k + \"=\" + pam_encode(params[k]);\n            if (i != l.length - 1) si += \"&\";\n        }\n        return si;\n    }\n\n    function validate_presence_heartbeat(heartbeat, cur_heartbeat, error) {\n        var err = false;\n\n        if (typeof heartbeat === 'undefined') {\n            return cur_heartbeat;\n        }\n\n        if (typeof heartbeat === 'number') {\n            if (heartbeat > PRESENCE_HB_THRESHOLD || heartbeat == 0) err = false;else err = true;\n        } else if (typeof heartbeat === 'boolean') {\n            if (!heartbeat) {\n                return 0;\n            } else {\n                return PRESENCE_HB_DEFAULT;\n            }\n        } else {\n            err = true;\n        }\n\n        if (err) {\n            error && error(\"Presence Heartbeat value invalid. Valid range ( x > \" + PRESENCE_HB_THRESHOLD + \" or x = 0). Current Value : \" + (cur_heartbeat || PRESENCE_HB_THRESHOLD));\n            return cur_heartbeat || PRESENCE_HB_THRESHOLD;\n        } else return heartbeat;\n    }\n\n    function encrypt(input, key) {\n        return crypto_obj['encrypt'](input, key || CIPHER_KEY) || input;\n    }\n    function decrypt(input, key) {\n        return crypto_obj['decrypt'](input, key || CIPHER_KEY) || crypto_obj['decrypt'](input, CIPHER_KEY) || input;\n    }\n\n    function error_common(message, callback) {\n        callback && callback({ 'error': message || \"error occurred\" });\n        _error && _error(message);\n    }\n    function _presence_heartbeat() {\n\n        clearTimeout(PRESENCE_HB_TIMEOUT);\n\n        if (!PRESENCE_HB_INTERVAL || PRESENCE_HB_INTERVAL >= 500 || PRESENCE_HB_INTERVAL < 1 || !generate_channel_list(CHANNELS, true).length && !generate_channel_group_list(CHANNEL_GROUPS, true).length) {\n            PRESENCE_HB_RUNNING = false;\n            return;\n        }\n\n        PRESENCE_HB_RUNNING = true;\n        SELF['presence_heartbeat']({\n            'callback': function callback(r) {\n                PRESENCE_HB_TIMEOUT = timeout(_presence_heartbeat, PRESENCE_HB_INTERVAL * SECOND);\n            },\n            'error': function error(e) {\n                _error && _error(\"Presence Heartbeat unable to reach Pubnub servers.\" + JSON.stringify(e));\n                PRESENCE_HB_TIMEOUT = timeout(_presence_heartbeat, PRESENCE_HB_INTERVAL * SECOND);\n            }\n        });\n    }\n\n    function start_presence_heartbeat() {\n        !PRESENCE_HB_RUNNING && _presence_heartbeat();\n    }\n\n    function _publish(next) {\n\n        if (NO_WAIT_FOR_PENDING) {\n            if (!PUB_QUEUE.length) return;\n        } else {\n            if (next) PUB_QUEUE.sending = 0;\n            if (PUB_QUEUE.sending || !PUB_QUEUE.length) return;\n            PUB_QUEUE.sending = 1;\n        }\n\n        xdr(PUB_QUEUE.shift());\n    }\n    function each_channel_group(callback) {\n        var count = 0;\n\n        each(generate_channel_group_list(CHANNEL_GROUPS), function (channel_group) {\n            var chang = CHANNEL_GROUPS[channel_group];\n\n            if (!chang) return;\n\n            count++;\n            (callback || function () {})(chang);\n        });\n\n        return count;\n    }\n\n    function each_channel(callback) {\n        var count = 0;\n\n        each(generate_channel_list(CHANNELS), function (channel) {\n            var chan = CHANNELS[channel];\n\n            if (!chan) return;\n\n            count++;\n            (callback || function () {})(chan);\n        });\n\n        return count;\n    }\n    function _invoke_callback(response, callback, err) {\n        if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) == 'object') {\n            if (response['error']) {\n                var callback_data = {};\n\n                if (response['message']) {\n                    callback_data['message'] = response['message'];\n                }\n\n                if (response['payload']) {\n                    callback_data['payload'] = response['payload'];\n                }\n\n                err && err(callback_data);\n                return;\n            }\n            if (response['payload']) {\n                if (response['next_page']) callback && callback(response['payload'], response['next_page']);else callback && callback(response['payload']);\n                return;\n            }\n        }\n        callback && callback(response);\n    }\n\n    function _invoke_error(response, err) {\n\n        if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) == 'object' && response['error']) {\n            var callback_data = {};\n\n            if (response['message']) {\n                callback_data['message'] = response['message'];\n            }\n\n            if (response['payload']) {\n                callback_data['payload'] = response['payload'];\n            }\n\n            err && err(callback_data);\n            return;\n        } else {\n            err && err(response);\n        }\n    }\n    function CR(args, callback, url1, data) {\n        var callback = args['callback'] || callback,\n            err = args['error'] || _error,\n            jsonp = jsonp_cb();\n\n        data = data || {};\n\n        if (!data['auth']) {\n            data['auth'] = args['auth_key'] || AUTH_KEY;\n        }\n\n        var url = [STD_ORIGIN, 'v1', 'channel-registration', 'sub-key', SUBSCRIBE_KEY];\n\n        url.push.apply(url, url1);\n\n        if (jsonp) data['callback'] = jsonp;\n\n        xdr({\n            callback: jsonp,\n            data: _get_url_params(data),\n            success: function success(response) {\n                _invoke_callback(response, callback, err);\n            },\n            fail: function fail(response) {\n                _invoke_error(response, err);\n            },\n            url: url\n        });\n    }\n\n    // Announce Leave Event\n    var SELF = {\n        'LEAVE': function LEAVE(channel, blocking, auth_key, callback, error) {\n\n            var data = { 'uuid': UUID, 'auth': auth_key || AUTH_KEY },\n                origin = nextorigin(ORIGIN),\n                callback = callback || function () {},\n                err = error || function () {},\n                url,\n                params,\n                jsonp = jsonp_cb();\n\n            // Prevent Leaving a Presence Channel\n            if (channel.indexOf(PRESENCE_SUFFIX) > 0) return true;\n\n            if (COMPATIBLE_35) {\n                if (!SSL) return false;\n                if (jsonp == '0') return false;\n            }\n\n            if (NOLEAVE) return false;\n\n            if (jsonp != '0') data['callback'] = jsonp;\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            url = [origin, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY, 'channel', encode(channel), 'leave'];\n\n            params = _get_url_params(data);\n\n            if (sendBeacon) {\n                url_string = build_url(url, params);\n                if (sendBeacon(url_string)) {\n                    callback && callback({ \"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\" });\n                    return true;\n                }\n            }\n\n            xdr({\n                blocking: blocking || SSL,\n                callback: jsonp,\n                data: params,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n            });\n            return true;\n        },\n        'LEAVE_GROUP': function LEAVE_GROUP(channel_group, blocking, auth_key, callback, error) {\n\n            var data = { 'uuid': UUID, 'auth': auth_key || AUTH_KEY },\n                origin = nextorigin(ORIGIN),\n                url,\n                params,\n                callback = callback || function () {},\n                err = error || function () {},\n                jsonp = jsonp_cb();\n\n            // Prevent Leaving a Presence Channel Group\n            if (channel_group.indexOf(PRESENCE_SUFFIX) > 0) return true;\n\n            if (COMPATIBLE_35) {\n                if (!SSL) return false;\n                if (jsonp == '0') return false;\n            }\n\n            if (NOLEAVE) return false;\n\n            if (jsonp != '0') data['callback'] = jsonp;\n\n            if (channel_group && channel_group.length > 0) data['channel-group'] = channel_group;\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            url = [origin, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY, 'channel', encode(','), 'leave'];\n\n            params = _get_url_params(data);\n\n            if (sendBeacon) {\n                url_string = build_url(url, params);\n                if (sendBeacon(url_string)) {\n                    callback && callback({ \"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\" });\n                    return true;\n                }\n            }\n\n            xdr({\n                blocking: blocking || SSL,\n                callback: jsonp,\n                data: params,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n            });\n            return true;\n        },\n        'set_resumed': function set_resumed(resumed) {\n            RESUMED = resumed;\n        },\n        'get_cipher_key': function get_cipher_key() {\n            return CIPHER_KEY;\n        },\n        'set_cipher_key': function set_cipher_key(key) {\n            CIPHER_KEY = key;\n        },\n        'raw_encrypt': function raw_encrypt(input, key) {\n            return encrypt(input, key);\n        },\n        'raw_decrypt': function raw_decrypt(input, key) {\n            return decrypt(input, key);\n        },\n        'get_heartbeat': function get_heartbeat() {\n            return PRESENCE_HB;\n        },\n\n        'set_heartbeat': function set_heartbeat(heartbeat, heartbeat_interval) {\n            PRESENCE_HB = validate_presence_heartbeat(heartbeat, PRESENCE_HB, _error);\n            PRESENCE_HB_INTERVAL = heartbeat_interval || PRESENCE_HB / 2 - 1;\n            if (PRESENCE_HB == 2) {\n                PRESENCE_HB_INTERVAL = 1;\n            }\n            CONNECT();\n            _presence_heartbeat();\n        },\n\n        'get_heartbeat_interval': function get_heartbeat_interval() {\n            return PRESENCE_HB_INTERVAL;\n        },\n\n        'set_heartbeat_interval': function set_heartbeat_interval(heartbeat_interval) {\n            PRESENCE_HB_INTERVAL = heartbeat_interval;\n            _presence_heartbeat();\n        },\n\n        'get_version': function get_version() {\n            return SDK_VER;\n        },\n        'getGcmMessageObject': function getGcmMessageObject(obj) {\n            return {\n                'data': obj\n            };\n        },\n        'getApnsMessageObject': function getApnsMessageObject(obj) {\n            var x = {\n                'aps': { 'badge': 1, 'alert': '' }\n            };\n            for (k in obj) {\n                k[x] = obj[k];\n            }\n            return x;\n        },\n        'newPnMessage': function newPnMessage() {\n            var x = {};\n            if (gcm) x['pn_gcm'] = gcm;\n            if (apns) x['pn_apns'] = apns;\n            for (k in n) {\n                x[k] = n[k];\n            }\n            return x;\n        },\n\n        '_add_param': function _add_param(key, val) {\n            params[key] = val;\n        },\n\n        'channel_group': function channel_group(args, callback) {\n            var ns_ch = args['channel_group'],\n                callback = callback || args['callback'],\n                channels = args['channels'] || args['channel'],\n                cloak = args['cloak'],\n                namespace,\n                channel_group,\n                url = [],\n                data = {},\n                mode = args['mode'] || 'add';\n\n            if (ns_ch) {\n                var ns_ch_a = ns_ch.split(':');\n\n                if (ns_ch_a.length > 1) {\n                    namespace = ns_ch_a[0] === '*' ? null : ns_ch_a[0];\n\n                    channel_group = ns_ch_a[1];\n                } else {\n                    channel_group = ns_ch_a[0];\n                }\n            }\n\n            namespace && url.push('namespace') && url.push(encode(namespace));\n\n            url.push('channel-group');\n\n            if (channel_group && channel_group !== '*') {\n                url.push(channel_group);\n            }\n\n            if (channels) {\n                if (isArray(channels)) {\n                    channels = channels.join(',');\n                }\n                data[mode] = channels;\n                data['cloak'] = CLOAK ? 'true' : 'false';\n            } else {\n                if (mode === 'remove') url.push('remove');\n            }\n\n            if (typeof cloak != 'undefined') data['cloak'] = cloak ? 'true' : 'false';\n\n            CR(args, callback, url, data);\n        },\n\n        'channel_group_list_groups': function channel_group_list_groups(args, callback) {\n            var namespace;\n\n            namespace = args['namespace'] || args['ns'] || args['channel_group'] || null;\n            if (namespace) {\n                args[\"channel_group\"] = namespace + \":*\";\n            }\n\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_list_channels': function channel_group_list_channels(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_remove_channel': function channel_group_remove_channel(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            if (!args['channel'] && !args['channels']) return _error('Missing Channel');\n\n            args['mode'] = 'remove';\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_remove_group': function channel_group_remove_group(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            if (args['channel']) return _error('Use channel_group_remove_channel if you want to remove a channel from a group.');\n\n            args['mode'] = 'remove';\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_add_channel': function channel_group_add_channel(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            if (!args['channel'] && !args['channels']) return _error('Missing Channel');\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_cloak': function channel_group_cloak(args, callback) {\n            if (typeof args['cloak'] == 'undefined') {\n                callback(CLOAK);\n                return;\n            }\n            CLOAK = args['cloak'];\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_list_namespaces': function channel_group_list_namespaces(args, callback) {\n            var url = ['namespace'];\n            CR(args, callback, url);\n        },\n        'channel_group_remove_namespace': function channel_group_remove_namespace(args, callback) {\n            var url = ['namespace', args['namespace'], 'remove'];\n            CR(args, callback, url);\n        },\n\n        /*\n            PUBNUB.history({\n                channel  : 'my_chat_channel',\n                limit    : 100,\n                callback : function(history) { }\n            });\n        */\n        'history': function history(args, callback) {\n            var callback = args['callback'] || callback,\n                count = args['count'] || args['limit'] || 100,\n                reverse = args['reverse'] || \"false\",\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                cipher_key = args['cipher_key'],\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                start = args['start'],\n                end = args['end'],\n                include_token = args['include_token'],\n                string_msg_token = args['string_message_token'] || false,\n                params = {},\n                jsonp = jsonp_cb();\n\n            // Make sure we have a Channel\n            if (!channel && !channel_group) return _error('Missing Channel');\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            params['stringtoken'] = 'true';\n            params['count'] = count;\n            params['reverse'] = reverse;\n            params['auth'] = auth_key;\n\n            if (channel_group) {\n                params['channel-group'] = channel_group;\n                if (!channel) {\n                    channel = ',';\n                }\n            }\n            if (jsonp) params['callback'] = jsonp;\n            if (start) params['start'] = start;\n            if (end) params['end'] = end;\n            if (include_token) params['include_token'] = 'true';\n            if (string_msg_token) params['string_message_token'] = 'true';\n\n            // Send Message\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(params),\n                success: function success(response) {\n                    if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) == 'object' && response['error']) {\n                        err({ 'message': response['message'], 'payload': response['payload'] });\n                        return;\n                    }\n                    var messages = response[0];\n                    var decrypted_messages = [];\n                    for (var a = 0; a < messages.length; a++) {\n                        if (include_token) {\n                            var new_message = decrypt(messages[a]['message'], cipher_key);\n                            var timetoken = messages[a]['timetoken'];\n                            try {\n                                decrypted_messages['push']({ \"message\": JSON['parse'](new_message), \"timetoken\": timetoken });\n                            } catch (e) {\n                                decrypted_messages['push']({ \"message\": new_message, \"timetoken\": timetoken });\n                            }\n                        } else {\n                            var new_message = decrypt(messages[a], cipher_key);\n                            try {\n                                decrypted_messages['push'](JSON['parse'](new_message));\n                            } catch (e) {\n                                decrypted_messages['push'](new_message);\n                            }\n                        }\n                    }\n                    callback([decrypted_messages, response[1], response[2]]);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v2', 'history', 'sub-key', SUBSCRIBE_KEY, 'channel', encode(channel)]\n            });\n        },\n\n        /*\n            PUBNUB.replay({\n                source      : 'my_channel',\n                destination : 'new_channel'\n            });\n        */\n        'replay': function replay(args, callback) {\n            var callback = callback || args['callback'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                source = args['source'],\n                destination = args['destination'],\n                stop = args['stop'],\n                start = args['start'],\n                end = args['end'],\n                reverse = args['reverse'],\n                limit = args['limit'],\n                jsonp = jsonp_cb(),\n                data = {},\n                url;\n\n            // Check User Input\n            if (!source) return _error('Missing Source Channel');\n            if (!destination) return _error('Missing Destination Channel');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            // Setup URL Params\n            if (jsonp != '0') data['callback'] = jsonp;\n            if (stop) data['stop'] = 'all';\n            if (reverse) data['reverse'] = 'true';\n            if (start) data['start'] = start;\n            if (end) data['end'] = end;\n            if (limit) data['count'] = limit;\n\n            data['auth'] = auth_key;\n\n            // Compose URL Parts\n            url = [STD_ORIGIN, 'v1', 'replay', PUBLISH_KEY, SUBSCRIBE_KEY, source, destination];\n\n            // Start (or Stop) Replay!\n            xdr({\n                callback: jsonp,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail() {\n                    callback([0, 'Disconnected']);\n                },\n                url: url,\n                data: _get_url_params(data)\n            });\n        },\n\n        /*\n            PUBNUB.auth('AJFLKAJSDKLA');\n        */\n        'auth': function auth(_auth) {\n            AUTH_KEY = _auth;\n            CONNECT();\n        },\n\n        /*\n            PUBNUB.time(function(time){ });\n        */\n        'time': function time(callback) {\n            var jsonp = jsonp_cb();\n\n            var data = { 'uuid': UUID, 'auth': AUTH_KEY };\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                url: [STD_ORIGIN, 'time', jsonp],\n                success: function success(response) {\n                    callback(response[0]);\n                },\n                fail: function fail() {\n                    callback(0);\n                }\n            });\n        },\n\n        /*\n            PUBNUB.publish({\n                channel : 'my_chat_channel',\n                message : 'hello!'\n            });\n        */\n        'publish': function publish(args, callback) {\n            var msg = args['message'];\n            if (!msg) return _error('Missing Message');\n\n            var callback = callback || args['callback'] || msg['callback'] || function () {},\n                channel = args['channel'] || msg['channel'],\n                auth_key = args['auth_key'] || AUTH_KEY,\n                cipher_key = args['cipher_key'],\n                err = args['error'] || msg['error'] || function () {},\n                post = args['post'] || false,\n                store = 'store_in_history' in args ? args['store_in_history'] : true,\n                jsonp = jsonp_cb(),\n                add_msg = 'push',\n                params,\n                url;\n\n            if (args['prepend']) add_msg = 'unshift';\n\n            if (!channel) return _error('Missing Channel');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            if (msg['getPubnubMessage']) {\n                msg = msg['getPubnubMessage']();\n            }\n\n            // If trying to send Object\n            msg = JSON['stringify'](encrypt(msg, cipher_key));\n\n            // Create URL\n            url = [STD_ORIGIN, 'publish', PUBLISH_KEY, SUBSCRIBE_KEY, 0, encode(channel), jsonp, encode(msg)];\n\n            params = { 'uuid': UUID, 'auth': auth_key };\n\n            if (!store) params['store'] = \"0\";\n\n            if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;\n\n            // Queue Message Send\n            PUB_QUEUE[add_msg]({\n                callback: jsonp,\n                url: url,\n                data: _get_url_params(params),\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                    _publish(1);\n                },\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                    _publish(1);\n                },\n                mode: post ? 'POST' : 'GET'\n            });\n\n            // Send Message\n            _publish();\n        },\n\n        /*\n            PUBNUB.unsubscribe({ channel : 'my_chat' });\n        */\n        'unsubscribe': function unsubscribe(args, callback) {\n            var channel = args['channel'],\n                channel_group = args['channel_group'],\n                auth_key = args['auth_key'] || AUTH_KEY,\n                callback = callback || args['callback'] || function () {},\n                err = args['error'] || function () {};\n\n            TIMETOKEN = 0;\n            SUB_RESTORE = 1; // REVISIT !!!!\n\n            if (channel) {\n\n                // Prepare LeaveChannel(s)\n                var leave_c = map((channel.join ? channel.join(',') : '' + channel).split(','), function (channel) {\n                    if (!CHANNELS[channel]) return;\n                    return channel;\n                }).join(',');\n\n                // Prepare Channel(s)\n                channel = map((channel.join ? channel.join(',') : '' + channel).split(','), function (channel) {\n                    if (!CHANNELS[channel]) return;\n                    return channel + ',' + channel + PRESENCE_SUFFIX;\n                }).join(',');\n\n                // Iterate over Channels\n                each(channel.split(','), function (ch) {\n                    if (!ch) return;\n                    CHANNELS[ch] = 0;\n                    if (ch in STATE) delete STATE[ch];\n                });\n\n                var CB_CALLED = true;\n                if (READY) {\n                    CB_CALLED = SELF['LEAVE'](leave_c, 0, auth_key, callback, err);\n                }\n                if (!CB_CALLED) callback({ action: \"leave\" });\n            }\n\n            if (channel_group) {\n\n                // Prepare channel group(s)\n                var leave_gc = map((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','), function (channel_group) {\n                    if (!CHANNEL_GROUPS[channel_group]) return;\n                    return channel_group;\n                }).join(',');\n\n                // Prepare channel group(s)\n                channel_group = map((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','), function (channel_group) {\n                    if (!CHANNEL_GROUPS[channel_group]) return;\n                    return channel_group + ',' + channel_group + PRESENCE_SUFFIX;\n                }).join(',');\n\n                // Iterate over channel groups\n                each(channel_group.split(','), function (chg) {\n                    if (!chg) return;\n                    CHANNEL_GROUPS[chg] = 0;\n                    if (chg in STATE) delete STATE[chg];\n                });\n\n                var CB_CALLED = true;\n                if (READY) {\n                    CB_CALLED = SELF['LEAVE_GROUP'](leave_gc, 0, auth_key, callback, err);\n                }\n                if (!CB_CALLED) callback({ action: \"leave\" });\n            }\n\n            // Reset Connection if Count Less\n            CONNECT();\n        },\n\n        /*\n            PUBNUB.subscribe({\n                channel  : 'my_chat'\n                callback : function(message) { }\n            });\n        */\n        'subscribe': function subscribe(args, callback) {\n            var channel = args['channel'],\n                channel_group = args['channel_group'],\n                callback = callback || args['callback'],\n                callback = callback || args['message'],\n                connect = args['connect'] || function () {},\n                reconnect = args['reconnect'] || function () {},\n                disconnect = args['disconnect'] || function () {},\n                SUB_ERROR = args['error'] || SUB_ERROR || function () {},\n                idlecb = args['idle'] || function () {},\n                presence = args['presence'] || 0,\n                noheresync = args['noheresync'] || 0,\n                backfill = args['backfill'] || 0,\n                timetoken = args['timetoken'] || 0,\n                sub_timeout = args['timeout'] || SUB_TIMEOUT,\n                windowing = args['windowing'] || SUB_WINDOWING,\n                state = args['state'],\n                heartbeat = args['heartbeat'] || args['pnexpires'],\n                heartbeat_interval = args['heartbeat_interval'],\n                restore = args['restore'] || SUB_RESTORE;\n\n            AUTH_KEY = args['auth_key'] || AUTH_KEY;\n\n            // Restore Enabled?\n            SUB_RESTORE = restore;\n\n            // Always Reset the TT\n            TIMETOKEN = timetoken;\n\n            // Make sure we have a Channel\n            if (!channel && !channel_group) {\n                return _error('Missing Channel');\n            }\n\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            if (heartbeat || heartbeat === 0 || heartbeat_interval || heartbeat_interval === 0) {\n                SELF['set_heartbeat'](heartbeat, heartbeat_interval);\n            }\n\n            // Setup Channel(s)\n            if (channel) {\n                each((channel.join ? channel.join(',') : '' + channel).split(','), function (channel) {\n                    var settings = CHANNELS[channel] || {};\n\n                    // Store Channel State\n                    CHANNELS[SUB_CHANNEL = channel] = {\n                        name: channel,\n                        connected: settings.connected,\n                        disconnected: settings.disconnected,\n                        subscribed: 1,\n                        callback: SUB_CALLBACK = callback,\n                        'cipher_key': args['cipher_key'],\n                        connect: connect,\n                        disconnect: disconnect,\n                        reconnect: reconnect\n                    };\n\n                    if (state) {\n                        if (channel in state) {\n                            STATE[channel] = state[channel];\n                        } else {\n                            STATE[channel] = state;\n                        }\n                    }\n\n                    // Presence Enabled?\n                    if (!presence) return;\n\n                    // Subscribe Presence Channel\n                    SELF['subscribe']({\n                        'channel': channel + PRESENCE_SUFFIX,\n                        'callback': presence,\n                        'restore': restore\n                    });\n\n                    // Presence Subscribed?\n                    if (settings.subscribed) return;\n\n                    // See Who's Here Now?\n                    if (noheresync) return;\n                    SELF['here_now']({\n                        'channel': channel,\n                        'data': _get_url_params({ 'uuid': UUID, 'auth': AUTH_KEY }),\n                        'callback': function callback(here) {\n                            each('uuids' in here ? here['uuids'] : [], function (uid) {\n                                presence({\n                                    'action': 'join',\n                                    'uuid': uid,\n                                    'timestamp': Math.floor(pubNubUtils.rnow() / 1000),\n                                    'occupancy': here['occupancy'] || 1\n                                }, here, channel);\n                            });\n                        }\n                    });\n                });\n            }\n\n            // Setup Channel Groups\n            if (channel_group) {\n                each((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','), function (channel_group) {\n                    var settings = CHANNEL_GROUPS[channel_group] || {};\n\n                    CHANNEL_GROUPS[channel_group] = {\n                        name: channel_group,\n                        connected: settings.connected,\n                        disconnected: settings.disconnected,\n                        subscribed: 1,\n                        callback: SUB_CALLBACK = callback,\n                        'cipher_key': args['cipher_key'],\n                        connect: connect,\n                        disconnect: disconnect,\n                        reconnect: reconnect\n                    };\n\n                    // Presence Enabled?\n                    if (!presence) return;\n\n                    // Subscribe Presence Channel\n                    SELF['subscribe']({\n                        'channel_group': channel_group + PRESENCE_SUFFIX,\n                        'callback': presence,\n                        'restore': restore,\n                        'auth_key': AUTH_KEY\n                    });\n\n                    // Presence Subscribed?\n                    if (settings.subscribed) return;\n\n                    // See Who's Here Now?\n                    if (noheresync) return;\n                    SELF['here_now']({\n                        'channel_group': channel_group,\n                        'data': _get_url_params({ 'uuid': UUID, 'auth': AUTH_KEY }),\n                        'callback': function callback(here) {\n                            each('uuids' in here ? here['uuids'] : [], function (uid) {\n                                presence({\n                                    'action': 'join',\n                                    'uuid': uid,\n                                    'timestamp': Math.floor(rnow() / 1000),\n                                    'occupancy': here['occupancy'] || 1\n                                }, here, channel_group);\n                            });\n                        }\n                    });\n                });\n            }\n\n            // Test Network Connection\n            function _test_connection(success) {\n                if (success) {\n                    // Begin Next Socket Connection\n                    timeout(CONNECT, windowing);\n                } else {\n                    // New Origin on Failed Connection\n                    STD_ORIGIN = nextorigin(ORIGIN, 1);\n                    SUB_ORIGIN = nextorigin(ORIGIN, 1);\n\n                    // Re-test Connection\n                    timeout(function () {\n                        SELF['time'](_test_connection);\n                    }, SECOND);\n                }\n\n                // Disconnect & Reconnect\n                each_channel(function (channel) {\n                    // Reconnect\n                    if (success && channel.disconnected) {\n                        channel.disconnected = 0;\n                        return channel.reconnect(channel.name);\n                    }\n\n                    // Disconnect\n                    if (!success && !channel.disconnected) {\n                        channel.disconnected = 1;\n                        channel.disconnect(channel.name);\n                    }\n                });\n\n                // Disconnect & Reconnect for channel groups\n                each_channel_group(function (channel_group) {\n                    // Reconnect\n                    if (success && channel_group.disconnected) {\n                        channel_group.disconnected = 0;\n                        return channel_group.reconnect(channel_group.name);\n                    }\n\n                    // Disconnect\n                    if (!success && !channel_group.disconnected) {\n                        channel_group.disconnected = 1;\n                        channel_group.disconnect(channel_group.name);\n                    }\n                });\n            }\n\n            // Evented Subscribe\n            function _connect() {\n                var jsonp = jsonp_cb(),\n                    channels = generate_channel_list(CHANNELS).join(','),\n                    channel_groups = generate_channel_group_list(CHANNEL_GROUPS).join(',');\n\n                // Stop Connection\n                if (!channels && !channel_groups) return;\n\n                if (!channels) channels = ',';\n\n                // Connect to PubNub Subscribe Servers\n                _reset_offline();\n\n                var data = _get_url_params({ 'uuid': UUID, 'auth': AUTH_KEY });\n\n                if (channel_groups) {\n                    data['channel-group'] = channel_groups;\n                }\n\n                var st = JSON.stringify(STATE);\n                if (st.length > 2) data['state'] = JSON.stringify(STATE);\n\n                if (PRESENCE_HB) data['heartbeat'] = PRESENCE_HB;\n\n                if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n                start_presence_heartbeat();\n                SUB_RECEIVER = xdr({\n                    timeout: sub_timeout,\n                    callback: jsonp,\n                    fail: function fail(response) {\n                        if (response && response['error'] && response['service']) {\n                            _invoke_error(response, SUB_ERROR);\n                            _test_connection(1);\n                        } else {\n                            SELF['time'](function (success) {\n                                !success && _invoke_error(response, SUB_ERROR);\n                                _test_connection(success);\n                            });\n                        }\n                    },\n                    data: _get_url_params(data),\n                    url: [SUB_ORIGIN, 'subscribe', SUBSCRIBE_KEY, encode(channels), jsonp, TIMETOKEN],\n                    success: function success(messages) {\n\n                        // Check for Errors\n                        if (!messages || (typeof messages === 'undefined' ? 'undefined' : _typeof(messages)) == 'object' && 'error' in messages && messages['error']) {\n                            SUB_ERROR(messages['error']);\n                            return timeout(CONNECT, SECOND);\n                        }\n\n                        // User Idle Callback\n                        idlecb(messages[1]);\n\n                        // Restore Previous Connection Point if Needed\n                        TIMETOKEN = !TIMETOKEN && SUB_RESTORE && db['get'](SUBSCRIBE_KEY) || messages[1];\n\n                        /*\n                        // Connect\n                        each_channel_registry(function(registry){\n                            if (registry.connected) return;\n                            registry.connected = 1;\n                            registry.connect(channel.name);\n                        });\n                        */\n\n                        // Connect\n                        each_channel(function (channel) {\n                            if (channel.connected) return;\n                            channel.connected = 1;\n                            channel.connect(channel.name);\n                        });\n\n                        // Connect for channel groups\n                        each_channel_group(function (channel_group) {\n                            if (channel_group.connected) return;\n                            channel_group.connected = 1;\n                            channel_group.connect(channel_group.name);\n                        });\n\n                        if (RESUMED && !SUB_RESTORE) {\n                            TIMETOKEN = 0;\n                            RESUMED = false;\n                            // Update Saved Timetoken\n                            db['set'](SUBSCRIBE_KEY, 0);\n                            timeout(_connect, windowing);\n                            return;\n                        }\n\n                        // Invoke Memory Catchup and Receive Up to 100\n                        // Previous Messages from the Queue.\n                        if (backfill) {\n                            TIMETOKEN = 10000;\n                            backfill = 0;\n                        }\n\n                        // Update Saved Timetoken\n                        db['set'](SUBSCRIBE_KEY, messages[1]);\n\n                        // Route Channel <---> Callback for Message\n                        var next_callback = (function () {\n                            var channels = '';\n                            var channels2 = '';\n\n                            if (messages.length > 3) {\n                                channels = messages[3];\n                                channels2 = messages[2];\n                            } else if (messages.length > 2) {\n                                channels = messages[2];\n                            } else {\n                                channels = map(generate_channel_list(CHANNELS), function (chan) {\n                                    return map(Array(messages[0].length).join(',').split(','), function () {\n                                        return chan;\n                                    });\n                                }).join(',');\n                            }\n\n                            var list = channels.split(',');\n                            var list2 = channels2 ? channels2.split(',') : [];\n\n                            return function () {\n                                var channel = list.shift() || SUB_CHANNEL;\n                                var channel2 = list2.shift();\n\n                                var chobj = {};\n\n                                if (channel2) {\n                                    if (channel && channel.indexOf('-pnpres') >= 0 && channel2.indexOf('-pnpres') < 0) {\n                                        channel2 += '-pnpres';\n                                    }\n                                    chobj = CHANNEL_GROUPS[channel2] || CHANNELS[channel2] || { 'callback': function callback() {} };\n                                } else {\n                                    chobj = CHANNELS[channel];\n                                }\n\n                                var r = [chobj.callback || SUB_CALLBACK, channel.split(PRESENCE_SUFFIX)[0]];\n                                channel2 && r.push(channel2.split(PRESENCE_SUFFIX)[0]);\n                                return r;\n                            };\n                        })();\n\n                        var latency = detect_latency(+messages[1]);\n                        each(messages[0], function (msg) {\n                            var next = next_callback();\n                            var decrypted_msg = decrypt(msg, CHANNELS[next[1]] ? CHANNELS[next[1]]['cipher_key'] : null);\n                            next[0] && next[0](decrypted_msg, messages, next[2] || next[1], latency, next[1]);\n                        });\n\n                        timeout(_connect, windowing);\n                    }\n                });\n            }\n\n            CONNECT = function () {\n                _reset_offline();\n                timeout(_connect, windowing);\n            };\n\n            // Reduce Status Flicker\n            if (!READY) return READY_BUFFER.push(CONNECT);\n\n            // Connect Now\n            CONNECT();\n        },\n\n        /*\n            PUBNUB.here_now({ channel : 'my_chat', callback : fun });\n        */\n        'here_now': function here_now(args, callback) {\n            var callback = args['callback'] || callback,\n                debug = args['debug'],\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                jsonp = jsonp_cb(),\n                uuids = 'uuids' in args ? args['uuids'] : true,\n                state = args['state'],\n                data = { 'uuid': UUID, 'auth': auth_key };\n\n            if (!uuids) data['disable_uuids'] = 1;\n            if (state) data['state'] = 1;\n\n            // Make sure we have a Channel\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            var url = [STD_ORIGIN, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY];\n\n            channel && url.push('channel') && url.push(encode(channel));\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            if (channel_group) {\n                data['channel-group'] = channel_group;\n                !channel && url.push('channel') && url.push(',');\n            }\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                debug: debug,\n                url: url\n            });\n        },\n\n        /*\n            PUBNUB.current_channels_by_uuid({ channel : 'my_chat', callback : fun });\n        */\n        'where_now': function where_now(args, callback) {\n            var callback = args['callback'] || callback,\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                jsonp = jsonp_cb(),\n                uuid = args['uuid'] || UUID,\n                data = { 'auth': auth_key };\n\n            // Make sure we have a Channel\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY, 'uuid', encode(uuid)]\n            });\n        },\n\n        'state': function state(args, callback) {\n            var callback = args['callback'] || callback || function (r) {},\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                jsonp = jsonp_cb(),\n                state = args['state'],\n                uuid = args['uuid'] || UUID,\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                url,\n                data = _get_url_params({ 'auth': auth_key });\n\n            // Make sure we have a Channel\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n            if (!uuid) return _error('Missing UUID');\n            if (!channel && !channel_group) return _error('Missing Channel');\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            if (typeof channel != 'undefined' && CHANNELS[channel] && CHANNELS[channel].subscribed) {\n                if (state) STATE[channel] = state;\n            }\n\n            if (typeof channel_group != 'undefined' && CHANNEL_GROUPS[channel_group] && CHANNEL_GROUPS[channel_group].subscribed) {\n                if (state) STATE[channel_group] = state;\n                data['channel-group'] = channel_group;\n\n                if (!channel) {\n                    channel = ',';\n                }\n            }\n\n            data['state'] = JSON.stringify(state);\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            if (state) {\n                url = [STD_ORIGIN, 'v2', 'presence', 'sub-key', SUBSCRIBE_KEY, 'channel', channel, 'uuid', uuid, 'data'];\n            } else {\n                url = [STD_ORIGIN, 'v2', 'presence', 'sub-key', SUBSCRIBE_KEY, 'channel', channel, 'uuid', encode(uuid)];\n            }\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n\n            });\n        },\n\n        /*\n            PUBNUB.grant({\n                channel  : 'my_chat',\n                callback : fun,\n                error    : fun,\n                ttl      : 24 * 60, // Minutes\n                read     : true,\n                write    : true,\n                auth_key : '3y8uiajdklytowsj'\n            });\n        */\n        'grant': function grant(args, callback) {\n            var callback = args['callback'] || callback,\n                err = args['error'] || function () {},\n                channel = args['channel'] || args['channels'],\n                channel_group = args['channel_group'],\n                jsonp = jsonp_cb(),\n                ttl = args['ttl'],\n                r = args['read'] ? \"1\" : \"0\",\n                w = args['write'] ? \"1\" : \"0\",\n                m = args['manage'] ? \"1\" : \"0\",\n                auth_key = args['auth_key'] || args['auth_keys'];\n\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SECRET_KEY) return _error('Missing Secret Key');\n\n            var timestamp = Math.floor(new Date().getTime() / 1000),\n                sign_input = SUBSCRIBE_KEY + \"\\n\" + PUBLISH_KEY + \"\\n\" + \"grant\" + \"\\n\";\n\n            var data = {\n                'w': w,\n                'r': r,\n                'timestamp': timestamp\n            };\n            if (args['manage']) {\n                data['m'] = m;\n            }\n            if (isArray(channel)) {\n                channel = channel['join'](',');\n            }\n            if (isArray(auth_key)) {\n                auth_key = auth_key['join'](',');\n            }\n            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n                data['channel-group'] = channel_group;\n            }\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n            if (ttl || ttl === 0) data['ttl'] = ttl;\n\n            if (auth_key) data['auth'] = auth_key;\n\n            data = _get_url_params(data);\n\n            if (!auth_key) delete data['auth'];\n\n            sign_input += _get_pam_sign_input_from_params(data);\n\n            var signature = hmac_SHA256(sign_input, SECRET_KEY);\n\n            signature = signature.replace(/\\+/g, \"-\");\n            signature = signature.replace(/\\//g, \"_\");\n\n            data['signature'] = signature;\n\n            xdr({\n                callback: jsonp,\n                data: data,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v1', 'auth', 'grant', 'sub-key', SUBSCRIBE_KEY]\n            });\n        },\n\n        /*\n         PUBNUB.mobile_gw_provision ({\n         device_id: 'A655FBA9931AB',\n         op       : 'add' | 'remove',\n         gw_type  : 'apns' | 'gcm',\n         channel  : 'my_chat',\n         callback : fun,\n         error    : fun,\n         });\n         */\n\n        'mobile_gw_provision': function mobile_gw_provision(args) {\n\n            var callback = args['callback'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                err = args['error'] || function () {},\n                jsonp = jsonp_cb(),\n                channel = args['channel'],\n                op = args['op'],\n                gw_type = args['gw_type'],\n                device_id = args['device_id'],\n                params,\n                url;\n\n            if (!device_id) return _error('Missing Device ID (device_id)');\n            if (!gw_type) return _error('Missing GW Type (gw_type: gcm or apns)');\n            if (!op) return _error('Missing GW Operation (op: add or remove)');\n            if (!channel) return _error('Missing gw destination Channel (channel)');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            // Create URL\n            url = [STD_ORIGIN, 'v1/push/sub-key', SUBSCRIBE_KEY, 'devices', device_id];\n\n            params = { 'uuid': UUID, 'auth': auth_key, 'type': gw_type };\n\n            if (op == \"add\") {\n                params['add'] = channel;\n            } else if (op == \"remove\") {\n                params['remove'] = channel;\n            }\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: params,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n            });\n        },\n\n        /*\n            PUBNUB.audit({\n                channel  : 'my_chat',\n                callback : fun,\n                error    : fun,\n                read     : true,\n                write    : true,\n                auth_key : '3y8uiajdklytowsj'\n            });\n        */\n        'audit': function audit(args, callback) {\n            var callback = args['callback'] || callback,\n                err = args['error'] || function () {},\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                auth_key = args['auth_key'],\n                jsonp = jsonp_cb();\n\n            // Make sure we have a Channel\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SECRET_KEY) return _error('Missing Secret Key');\n\n            var timestamp = Math.floor(new Date().getTime() / 1000),\n                sign_input = SUBSCRIBE_KEY + \"\\n\" + PUBLISH_KEY + \"\\n\" + \"audit\" + \"\\n\";\n\n            var data = { 'timestamp': timestamp };\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n                data['channel-group'] = channel_group;\n            }\n            if (auth_key) data['auth'] = auth_key;\n\n            data = _get_url_params(data);\n\n            if (!auth_key) delete data['auth'];\n\n            sign_input += _get_pam_sign_input_from_params(data);\n\n            var signature = hmac_SHA256(sign_input, SECRET_KEY);\n\n            signature = signature.replace(/\\+/g, \"-\");\n            signature = signature.replace(/\\//g, \"_\");\n\n            data['signature'] = signature;\n            xdr({\n                callback: jsonp,\n                data: data,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v1', 'auth', 'audit', 'sub-key', SUBSCRIBE_KEY]\n            });\n        },\n\n        /*\n            PUBNUB.revoke({\n                channel  : 'my_chat',\n                callback : fun,\n                error    : fun,\n                auth_key : '3y8uiajdklytowsj'\n            });\n        */\n        'revoke': function revoke(args, callback) {\n            args['read'] = false;\n            args['write'] = false;\n            SELF['grant'](args, callback);\n        },\n        'set_uuid': function set_uuid(uuid) {\n            UUID = uuid;\n            CONNECT();\n        },\n        'get_uuid': function get_uuid() {\n            return UUID;\n        },\n        'isArray': (function (_isArray) {\n            function isArray(_x) {\n                return _isArray.apply(this, arguments);\n            }\n\n            isArray.toString = function () {\n                return _isArray.toString();\n            };\n\n            return isArray;\n        })(function (arg) {\n            return isArray(arg);\n        }),\n        'get_subscibed_channels': function get_subscibed_channels() {\n            return generate_channel_list(CHANNELS, true);\n        },\n        'presence_heartbeat': function presence_heartbeat(args) {\n            var callback = args['callback'] || function () {};\n            var err = args['error'] || function () {};\n            var jsonp = jsonp_cb();\n            var data = { 'uuid': UUID, 'auth': AUTH_KEY };\n\n            var st = JSON['stringify'](STATE);\n            if (st.length > 2) data['state'] = JSON['stringify'](STATE);\n\n            if (PRESENCE_HB > 0 && PRESENCE_HB < 320) data['heartbeat'] = PRESENCE_HB;\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            var channels = encode(generate_channel_list(CHANNELS, true)['join'](','));\n            var channel_groups = generate_channel_group_list(CHANNEL_GROUPS, true)['join'](',');\n\n            if (!channels) channels = ',';\n            if (channel_groups) data['channel-group'] = channel_groups;\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                url: [STD_ORIGIN, 'v2', 'presence', 'sub-key', SUBSCRIBE_KEY, 'channel', channels, 'heartbeat'],\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                }\n            });\n        },\n        'stop_timers': function stop_timers() {\n            clearTimeout(_poll_timer);\n            clearTimeout(_poll_timer2);\n            clearTimeout(PRESENCE_HB_TIMEOUT);\n        },\n        'shutdown': function shutdown() {\n            SELF['stop_timers']();\n            _shutdown && _shutdown();\n        },\n\n        // Expose PUBNUB Functions\n        'xdr': xdr,\n        'ready': ready,\n        'db': db,\n        'uuid': generate_uuid,\n        'map': map,\n        'each': each,\n        'each-channel': each_channel,\n        'grep': grep,\n        'offline': function offline() {\n            _reset_offline(1, { \"message\": \"Offline. Please check your network settings.\" });\n        },\n        'supplant': supplant,\n        'now': rnow,\n        'unique': unique,\n        'updater': updater\n    };\n\n    function _poll_online() {\n        _is_online() || _reset_offline(1, {\n            \"error\": \"Offline. Please check your network settings. \"\n        });\n        _poll_timer && clearTimeout(_poll_timer);\n        _poll_timer = timeout(_poll_online, SECOND);\n    }\n\n    function _poll_online2() {\n        if (!TIME_CHECK) return;\n        SELF['time'](function (success) {\n            detect_time_detla(function () {}, success);\n            success || _reset_offline(1, {\n                \"error\": \"Heartbeat failed to connect to Pubnub Servers.\" + \"Please check your network settings.\"\n            });\n            _poll_timer2 && clearTimeout(_poll_timer2);\n            _poll_timer2 = timeout(_poll_online2, KEEPALIVE);\n        });\n    }\n\n    function _reset_offline(err, msg) {\n        SUB_RECEIVER && SUB_RECEIVER(err, msg);\n        SUB_RECEIVER = null;\n\n        clearTimeout(_poll_timer);\n        clearTimeout(_poll_timer2);\n    }\n\n    if (!UUID) UUID = SELF['uuid']();\n    if (!INSTANCEID) INSTANCEID = SELF['uuid']();\n    db['set'](SUBSCRIBE_KEY + 'uuid', UUID);\n\n    _poll_timer = timeout(_poll_online, SECOND);\n    _poll_timer2 = timeout(_poll_online2, KEEPALIVE);\n    PRESENCE_HB_TIMEOUT = timeout(start_presence_heartbeat, (PRESENCE_HB_INTERVAL - 3) * SECOND);\n\n    // Detect Age of Message\n    function detect_latency(tt) {\n        var adjusted_time = rnow() - TIME_DRIFT;\n        return adjusted_time - tt / 10000;\n    }\n\n    detect_time_detla();\n    function detect_time_detla(cb, time) {\n        var stime = rnow();\n\n        time && calculate(time) || SELF['time'](calculate);\n\n        function calculate(time) {\n            if (!time) return;\n            var ptime = time / 10000,\n                latency = (pubNubUtils.rnow() - stime) / 2;\n            TIME_DRIFT = pubNubUtils.rnow() - (ptime + latency);\n            cb && cb(TIME_DRIFT);\n        }\n    }\n\n    return SELF;\n}","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar _utils = require('./utils');\n\nvar pubNubUtils = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _typeof(obj) { return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }\n\nvar NOW = 1,\n    READY = false,\n    READY_BUFFER = [],\n    PRESENCE_SUFFIX = '-pnpres',\n    DEF_WINDOWING = 10 // MILLISECONDS.\n,\n    DEF_TIMEOUT = 15000 // MILLISECONDS.\n,\n    DEF_SUB_TIMEOUT = 310 // SECONDS.\n,\n    DEF_KEEPALIVE = 60 // SECONDS (FOR TIMESYNC).\n,\n    SECOND = 1000 // A THOUSAND MILLISECONDS.\n,\n    PRESENCE_HB_THRESHOLD = 5,\n    PRESENCE_HB_DEFAULT = 30,\n    SDK_VER = VERSION;\n\nfunction pam_encode(str) {\n    return encodeURIComponent(str).replace(/[!'()*~]/g, function (c) {\n        return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n    });\n}\n\n/**\n * Generate Subscription Channel List\n * ==================================\n * generate_channel_list(channels_object);\n */\nfunction generate_channel_list(channels, nopresence) {\n    var list = [];\n    each(channels, function (channel, status) {\n        if (nopresence) {\n            if (channel.search('-pnpres') < 0) {\n                if (status.subscribed) list.push(channel);\n            }\n        } else {\n            if (status.subscribed) list.push(channel);\n        }\n    });\n    return list.sort();\n}\n\n/**\n * Generate Subscription Channel Groups List\n * ==================================\n * generate_channel_group_list(channels_groups object);\n */\nfunction generate_channel_group_list(channel_groups, nopresence) {\n    var list = [];\n    each(channel_groups, function (channel_group, status) {\n        if (nopresence) {\n            if (channel_group.search('-pnpres') < 0) {\n                if (status.subscribed) list.push(channel_group);\n            }\n        } else {\n            if (status.subscribed) list.push(channel_group);\n        }\n    });\n    return list.sort();\n}\n\n// PUBNUB READY TO CONNECT\nfunction ready() {\n    timeout(function () {\n        if (READY) return;\n        READY = 1;\n        each(READY_BUFFER, function (connect) {\n            connect();\n        });\n    }, SECOND);\n}\n\nfunction PNmessage(args) {\n    msg = args || { 'apns': {} }, msg['getPubnubMessage'] = function () {\n        var m = {};\n\n        if (Object.keys(msg['apns']).length) {\n            m['pn_apns'] = {\n                'aps': {\n                    'alert': msg['apns']['alert'],\n                    'badge': msg['apns']['badge']\n                }\n            };\n            for (var k in msg['apns']) {\n                m['pn_apns'][k] = msg['apns'][k];\n            }\n            var exclude1 = ['badge', 'alert'];\n            for (var k in exclude1) {\n                delete m['pn_apns'][exclude1[k]];\n            }\n        }\n\n        if (msg['gcm']) {\n            m['pn_gcm'] = {\n                'data': msg['gcm']\n            };\n        }\n\n        for (var k in msg) {\n            m[k] = msg[k];\n        }\n        var exclude = ['apns', 'gcm', 'publish', 'channel', 'callback', 'error'];\n        for (var k in exclude) {\n            delete m[exclude[k]];\n        }\n\n        return m;\n    };\n    msg['publish'] = function () {\n\n        var m = msg.getPubnubMessage();\n\n        if (msg['pubnub'] && msg['channel']) {\n            msg['pubnub'].publish({\n                'message': m,\n                'channel': msg['channel'],\n                'callback': msg['callback'],\n                'error': msg['error']\n            });\n        }\n    };\n    return msg;\n}\n\nfunction PN_API(setup) {\n    var SUB_WINDOWING = +setup['windowing'] || DEF_WINDOWING,\n        SUB_TIMEOUT = (+setup['timeout'] || DEF_SUB_TIMEOUT) * SECOND,\n        KEEPALIVE = (+setup['keepalive'] || DEF_KEEPALIVE) * SECOND,\n        TIME_CHECK = setup['timecheck'] || 0,\n        NOLEAVE = setup['noleave'] || 0,\n        PUBLISH_KEY = setup['publish_key'],\n        SUBSCRIBE_KEY = setup['subscribe_key'],\n        AUTH_KEY = setup['auth_key'] || '',\n        SECRET_KEY = setup['secret_key'] || '',\n        hmac_SHA256 = setup['hmac_SHA256'],\n        SSL = setup['ssl'] ? 's' : '',\n        ORIGIN = 'http' + SSL + '://' + (setup['origin'] || 'pubsub.pubnub.com'),\n        STD_ORIGIN = nextorigin(ORIGIN),\n        SUB_ORIGIN = nextorigin(ORIGIN),\n        CONNECT = function CONNECT() {},\n        PUB_QUEUE = [],\n        CLOAK = true,\n        TIME_DRIFT = 0,\n        SUB_CALLBACK = 0,\n        SUB_CHANNEL = 0,\n        SUB_RECEIVER = 0,\n        SUB_RESTORE = setup['restore'] || 0,\n        SUB_BUFF_WAIT = 0,\n        TIMETOKEN = 0,\n        RESUMED = false,\n        CHANNELS = {},\n        CHANNEL_GROUPS = {},\n        SUB_ERROR = function SUB_ERROR() {},\n        STATE = {},\n        PRESENCE_HB_TIMEOUT = null,\n        PRESENCE_HB = validate_presence_heartbeat(setup['heartbeat'] || setup['pnexpires'] || 0, setup['error']),\n        PRESENCE_HB_INTERVAL = setup['heartbeat_interval'] || PRESENCE_HB / 2 - 1,\n        PRESENCE_HB_RUNNING = false,\n        NO_WAIT_FOR_PENDING = setup['no_wait_for_pending'],\n        COMPATIBLE_35 = setup['compatible_3.5'] || false,\n        xdr = setup['xdr'],\n        params = setup['params'] || {},\n        _error = setup['error'] || function () {},\n        _is_online = setup['_is_online'] || function () {\n        return 1;\n    },\n        jsonp_cb = setup['jsonp_cb'] || function () {\n        return 0;\n    },\n        db = setup['db'] || { 'get': function get() {}, 'set': function set() {} },\n        CIPHER_KEY = setup['cipher_key'],\n        UUID = setup['uuid'] || !setup['unique_uuid'] && db && db['get'](SUBSCRIBE_KEY + 'uuid') || '',\n        USE_INSTANCEID = setup['instance_id'] || false,\n        INSTANCEID = '',\n        _shutdown = setup['shutdown'],\n        use_send_beacon = typeof setup['use_send_beacon'] != 'undefined' ? setup['use_send_beacon'] : true,\n        sendBeacon = use_send_beacon ? setup['sendBeacon'] : null,\n        _poll_timer,\n        _poll_timer2;\n\n    if (PRESENCE_HB === 2) PRESENCE_HB_INTERVAL = 1;\n\n    var crypto_obj = setup['crypto_obj'] || {\n        'encrypt': function encrypt(a, key) {\n            return a;\n        },\n        'decrypt': function decrypt(b, key) {\n            return b;\n        }\n    };\n\n    function _get_url_params(data) {\n        if (!data) data = {};\n        each(params, function (key, value) {\n            if (!(key in data)) data[key] = value;\n        });\n        return data;\n    }\n\n    function _object_to_key_list(o) {\n        var l = [];\n        each(o, function (key, value) {\n            l.push(key);\n        });\n        return l;\n    }\n    function _object_to_key_list_sorted(o) {\n        return _object_to_key_list(o).sort();\n    }\n\n    function _get_pam_sign_input_from_params(params) {\n        var si = \"\";\n        var l = _object_to_key_list_sorted(params);\n\n        for (var i in l) {\n            var k = l[i];\n            si += k + \"=\" + pam_encode(params[k]);\n            if (i != l.length - 1) si += \"&\";\n        }\n        return si;\n    }\n\n    function validate_presence_heartbeat(heartbeat, cur_heartbeat, error) {\n        var err = false;\n\n        if (typeof heartbeat === 'undefined') {\n            return cur_heartbeat;\n        }\n\n        if (typeof heartbeat === 'number') {\n            if (heartbeat > PRESENCE_HB_THRESHOLD || heartbeat == 0) err = false;else err = true;\n        } else if (typeof heartbeat === 'boolean') {\n            if (!heartbeat) {\n                return 0;\n            } else {\n                return PRESENCE_HB_DEFAULT;\n            }\n        } else {\n            err = true;\n        }\n\n        if (err) {\n            error && error(\"Presence Heartbeat value invalid. Valid range ( x > \" + PRESENCE_HB_THRESHOLD + \" or x = 0). Current Value : \" + (cur_heartbeat || PRESENCE_HB_THRESHOLD));\n            return cur_heartbeat || PRESENCE_HB_THRESHOLD;\n        } else return heartbeat;\n    }\n\n    function encrypt(input, key) {\n        return crypto_obj['encrypt'](input, key || CIPHER_KEY) || input;\n    }\n    function decrypt(input, key) {\n        return crypto_obj['decrypt'](input, key || CIPHER_KEY) || crypto_obj['decrypt'](input, CIPHER_KEY) || input;\n    }\n\n    function error_common(message, callback) {\n        callback && callback({ 'error': message || \"error occurred\" });\n        _error && _error(message);\n    }\n    function _presence_heartbeat() {\n\n        clearTimeout(PRESENCE_HB_TIMEOUT);\n\n        if (!PRESENCE_HB_INTERVAL || PRESENCE_HB_INTERVAL >= 500 || PRESENCE_HB_INTERVAL < 1 || !generate_channel_list(CHANNELS, true).length && !generate_channel_group_list(CHANNEL_GROUPS, true).length) {\n            PRESENCE_HB_RUNNING = false;\n            return;\n        }\n\n        PRESENCE_HB_RUNNING = true;\n        SELF['presence_heartbeat']({\n            'callback': function callback(r) {\n                PRESENCE_HB_TIMEOUT = timeout(_presence_heartbeat, PRESENCE_HB_INTERVAL * SECOND);\n            },\n            'error': function error(e) {\n                _error && _error(\"Presence Heartbeat unable to reach Pubnub servers.\" + JSON.stringify(e));\n                PRESENCE_HB_TIMEOUT = timeout(_presence_heartbeat, PRESENCE_HB_INTERVAL * SECOND);\n            }\n        });\n    }\n\n    function start_presence_heartbeat() {\n        !PRESENCE_HB_RUNNING && _presence_heartbeat();\n    }\n\n    function _publish(next) {\n\n        if (NO_WAIT_FOR_PENDING) {\n            if (!PUB_QUEUE.length) return;\n        } else {\n            if (next) PUB_QUEUE.sending = 0;\n            if (PUB_QUEUE.sending || !PUB_QUEUE.length) return;\n            PUB_QUEUE.sending = 1;\n        }\n\n        xdr(PUB_QUEUE.shift());\n    }\n    function each_channel_group(callback) {\n        var count = 0;\n\n        each(generate_channel_group_list(CHANNEL_GROUPS), function (channel_group) {\n            var chang = CHANNEL_GROUPS[channel_group];\n\n            if (!chang) return;\n\n            count++;\n            (callback || function () {})(chang);\n        });\n\n        return count;\n    }\n\n    function each_channel(callback) {\n        var count = 0;\n\n        each(generate_channel_list(CHANNELS), function (channel) {\n            var chan = CHANNELS[channel];\n\n            if (!chan) return;\n\n            count++;\n            (callback || function () {})(chan);\n        });\n\n        return count;\n    }\n    function _invoke_callback(response, callback, err) {\n        if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) == 'object') {\n            if (response['error']) {\n                var callback_data = {};\n\n                if (response['message']) {\n                    callback_data['message'] = response['message'];\n                }\n\n                if (response['payload']) {\n                    callback_data['payload'] = response['payload'];\n                }\n\n                err && err(callback_data);\n                return;\n            }\n            if (response['payload']) {\n                if (response['next_page']) callback && callback(response['payload'], response['next_page']);else callback && callback(response['payload']);\n                return;\n            }\n        }\n        callback && callback(response);\n    }\n\n    function _invoke_error(response, err) {\n\n        if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) == 'object' && response['error']) {\n            var callback_data = {};\n\n            if (response['message']) {\n                callback_data['message'] = response['message'];\n            }\n\n            if (response['payload']) {\n                callback_data['payload'] = response['payload'];\n            }\n\n            err && err(callback_data);\n            return;\n        } else {\n            err && err(response);\n        }\n    }\n    function CR(args, callback, url1, data) {\n        var callback = args['callback'] || callback,\n            err = args['error'] || _error,\n            jsonp = jsonp_cb();\n\n        data = data || {};\n\n        if (!data['auth']) {\n            data['auth'] = args['auth_key'] || AUTH_KEY;\n        }\n\n        var url = [STD_ORIGIN, 'v1', 'channel-registration', 'sub-key', SUBSCRIBE_KEY];\n\n        url.push.apply(url, url1);\n\n        if (jsonp) data['callback'] = jsonp;\n\n        xdr({\n            callback: jsonp,\n            data: _get_url_params(data),\n            success: function success(response) {\n                _invoke_callback(response, callback, err);\n            },\n            fail: function fail(response) {\n                _invoke_error(response, err);\n            },\n            url: url\n        });\n    }\n\n    // Announce Leave Event\n    var SELF = {\n        'LEAVE': function LEAVE(channel, blocking, auth_key, callback, error) {\n\n            var data = { 'uuid': UUID, 'auth': auth_key || AUTH_KEY },\n                origin = nextorigin(ORIGIN),\n                callback = callback || function () {},\n                err = error || function () {},\n                url,\n                params,\n                jsonp = jsonp_cb();\n\n            // Prevent Leaving a Presence Channel\n            if (channel.indexOf(PRESENCE_SUFFIX) > 0) return true;\n\n            if (COMPATIBLE_35) {\n                if (!SSL) return false;\n                if (jsonp == '0') return false;\n            }\n\n            if (NOLEAVE) return false;\n\n            if (jsonp != '0') data['callback'] = jsonp;\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            url = [origin, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY, 'channel', encode(channel), 'leave'];\n\n            params = _get_url_params(data);\n\n            if (sendBeacon) {\n                url_string = build_url(url, params);\n                if (sendBeacon(url_string)) {\n                    callback && callback({ \"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\" });\n                    return true;\n                }\n            }\n\n            xdr({\n                blocking: blocking || SSL,\n                callback: jsonp,\n                data: params,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n            });\n            return true;\n        },\n        'LEAVE_GROUP': function LEAVE_GROUP(channel_group, blocking, auth_key, callback, error) {\n\n            var data = { 'uuid': UUID, 'auth': auth_key || AUTH_KEY },\n                origin = nextorigin(ORIGIN),\n                url,\n                params,\n                callback = callback || function () {},\n                err = error || function () {},\n                jsonp = jsonp_cb();\n\n            // Prevent Leaving a Presence Channel Group\n            if (channel_group.indexOf(PRESENCE_SUFFIX) > 0) return true;\n\n            if (COMPATIBLE_35) {\n                if (!SSL) return false;\n                if (jsonp == '0') return false;\n            }\n\n            if (NOLEAVE) return false;\n\n            if (jsonp != '0') data['callback'] = jsonp;\n\n            if (channel_group && channel_group.length > 0) data['channel-group'] = channel_group;\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            url = [origin, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY, 'channel', encode(','), 'leave'];\n\n            params = _get_url_params(data);\n\n            if (sendBeacon) {\n                url_string = build_url(url, params);\n                if (sendBeacon(url_string)) {\n                    callback && callback({ \"status\": 200, \"action\": \"leave\", \"message\": \"OK\", \"service\": \"Presence\" });\n                    return true;\n                }\n            }\n\n            xdr({\n                blocking: blocking || SSL,\n                callback: jsonp,\n                data: params,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n            });\n            return true;\n        },\n        'set_resumed': function set_resumed(resumed) {\n            RESUMED = resumed;\n        },\n        'get_cipher_key': function get_cipher_key() {\n            return CIPHER_KEY;\n        },\n        'set_cipher_key': function set_cipher_key(key) {\n            CIPHER_KEY = key;\n        },\n        'raw_encrypt': function raw_encrypt(input, key) {\n            return encrypt(input, key);\n        },\n        'raw_decrypt': function raw_decrypt(input, key) {\n            return decrypt(input, key);\n        },\n        'get_heartbeat': function get_heartbeat() {\n            return PRESENCE_HB;\n        },\n\n        'set_heartbeat': function set_heartbeat(heartbeat, heartbeat_interval) {\n            PRESENCE_HB = validate_presence_heartbeat(heartbeat, PRESENCE_HB, _error);\n            PRESENCE_HB_INTERVAL = heartbeat_interval || PRESENCE_HB / 2 - 1;\n            if (PRESENCE_HB == 2) {\n                PRESENCE_HB_INTERVAL = 1;\n            }\n            CONNECT();\n            _presence_heartbeat();\n        },\n\n        'get_heartbeat_interval': function get_heartbeat_interval() {\n            return PRESENCE_HB_INTERVAL;\n        },\n\n        'set_heartbeat_interval': function set_heartbeat_interval(heartbeat_interval) {\n            PRESENCE_HB_INTERVAL = heartbeat_interval;\n            _presence_heartbeat();\n        },\n\n        'get_version': function get_version() {\n            return SDK_VER;\n        },\n        'getGcmMessageObject': function getGcmMessageObject(obj) {\n            return {\n                'data': obj\n            };\n        },\n        'getApnsMessageObject': function getApnsMessageObject(obj) {\n            var x = {\n                'aps': { 'badge': 1, 'alert': '' }\n            };\n            for (k in obj) {\n                k[x] = obj[k];\n            }\n            return x;\n        },\n        'newPnMessage': function newPnMessage() {\n            var x = {};\n            if (gcm) x['pn_gcm'] = gcm;\n            if (apns) x['pn_apns'] = apns;\n            for (k in n) {\n                x[k] = n[k];\n            }\n            return x;\n        },\n\n        '_add_param': function _add_param(key, val) {\n            params[key] = val;\n        },\n\n        'channel_group': function channel_group(args, callback) {\n            var ns_ch = args['channel_group'],\n                callback = callback || args['callback'],\n                channels = args['channels'] || args['channel'],\n                cloak = args['cloak'],\n                namespace,\n                channel_group,\n                url = [],\n                data = {},\n                mode = args['mode'] || 'add';\n\n            if (ns_ch) {\n                var ns_ch_a = ns_ch.split(':');\n\n                if (ns_ch_a.length > 1) {\n                    namespace = ns_ch_a[0] === '*' ? null : ns_ch_a[0];\n\n                    channel_group = ns_ch_a[1];\n                } else {\n                    channel_group = ns_ch_a[0];\n                }\n            }\n\n            namespace && url.push('namespace') && url.push(encode(namespace));\n\n            url.push('channel-group');\n\n            if (channel_group && channel_group !== '*') {\n                url.push(channel_group);\n            }\n\n            if (channels) {\n                if (isArray(channels)) {\n                    channels = channels.join(',');\n                }\n                data[mode] = channels;\n                data['cloak'] = CLOAK ? 'true' : 'false';\n            } else {\n                if (mode === 'remove') url.push('remove');\n            }\n\n            if (typeof cloak != 'undefined') data['cloak'] = cloak ? 'true' : 'false';\n\n            CR(args, callback, url, data);\n        },\n\n        'channel_group_list_groups': function channel_group_list_groups(args, callback) {\n            var namespace;\n\n            namespace = args['namespace'] || args['ns'] || args['channel_group'] || null;\n            if (namespace) {\n                args[\"channel_group\"] = namespace + \":*\";\n            }\n\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_list_channels': function channel_group_list_channels(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_remove_channel': function channel_group_remove_channel(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            if (!args['channel'] && !args['channels']) return _error('Missing Channel');\n\n            args['mode'] = 'remove';\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_remove_group': function channel_group_remove_group(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            if (args['channel']) return _error('Use channel_group_remove_channel if you want to remove a channel from a group.');\n\n            args['mode'] = 'remove';\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_add_channel': function channel_group_add_channel(args, callback) {\n            if (!args['channel_group']) return _error('Missing Channel Group');\n            if (!args['channel'] && !args['channels']) return _error('Missing Channel');\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_cloak': function channel_group_cloak(args, callback) {\n            if (typeof args['cloak'] == 'undefined') {\n                callback(CLOAK);\n                return;\n            }\n            CLOAK = args['cloak'];\n            SELF['channel_group'](args, callback);\n        },\n\n        'channel_group_list_namespaces': function channel_group_list_namespaces(args, callback) {\n            var url = ['namespace'];\n            CR(args, callback, url);\n        },\n        'channel_group_remove_namespace': function channel_group_remove_namespace(args, callback) {\n            var url = ['namespace', args['namespace'], 'remove'];\n            CR(args, callback, url);\n        },\n\n        /*\n            PUBNUB.history({\n                channel  : 'my_chat_channel',\n                limit    : 100,\n                callback : function(history) { }\n            });\n        */\n        'history': function history(args, callback) {\n            var callback = args['callback'] || callback,\n                count = args['count'] || args['limit'] || 100,\n                reverse = args['reverse'] || \"false\",\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                cipher_key = args['cipher_key'],\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                start = args['start'],\n                end = args['end'],\n                include_token = args['include_token'],\n                string_msg_token = args['string_message_token'] || false,\n                params = {},\n                jsonp = jsonp_cb();\n\n            // Make sure we have a Channel\n            if (!channel && !channel_group) return _error('Missing Channel');\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            params['stringtoken'] = 'true';\n            params['count'] = count;\n            params['reverse'] = reverse;\n            params['auth'] = auth_key;\n\n            if (channel_group) {\n                params['channel-group'] = channel_group;\n                if (!channel) {\n                    channel = ',';\n                }\n            }\n            if (jsonp) params['callback'] = jsonp;\n            if (start) params['start'] = start;\n            if (end) params['end'] = end;\n            if (include_token) params['include_token'] = 'true';\n            if (string_msg_token) params['string_message_token'] = 'true';\n\n            // Send Message\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(params),\n                success: function success(response) {\n                    if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) == 'object' && response['error']) {\n                        err({ 'message': response['message'], 'payload': response['payload'] });\n                        return;\n                    }\n                    var messages = response[0];\n                    var decrypted_messages = [];\n                    for (var a = 0; a < messages.length; a++) {\n                        if (include_token) {\n                            var new_message = decrypt(messages[a]['message'], cipher_key);\n                            var timetoken = messages[a]['timetoken'];\n                            try {\n                                decrypted_messages['push']({ \"message\": JSON['parse'](new_message), \"timetoken\": timetoken });\n                            } catch (e) {\n                                decrypted_messages['push']({ \"message\": new_message, \"timetoken\": timetoken });\n                            }\n                        } else {\n                            var new_message = decrypt(messages[a], cipher_key);\n                            try {\n                                decrypted_messages['push'](JSON['parse'](new_message));\n                            } catch (e) {\n                                decrypted_messages['push'](new_message);\n                            }\n                        }\n                    }\n                    callback([decrypted_messages, response[1], response[2]]);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v2', 'history', 'sub-key', SUBSCRIBE_KEY, 'channel', encode(channel)]\n            });\n        },\n\n        /*\n            PUBNUB.replay({\n                source      : 'my_channel',\n                destination : 'new_channel'\n            });\n        */\n        'replay': function replay(args, callback) {\n            var callback = callback || args['callback'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                source = args['source'],\n                destination = args['destination'],\n                stop = args['stop'],\n                start = args['start'],\n                end = args['end'],\n                reverse = args['reverse'],\n                limit = args['limit'],\n                jsonp = jsonp_cb(),\n                data = {},\n                url;\n\n            // Check User Input\n            if (!source) return _error('Missing Source Channel');\n            if (!destination) return _error('Missing Destination Channel');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            // Setup URL Params\n            if (jsonp != '0') data['callback'] = jsonp;\n            if (stop) data['stop'] = 'all';\n            if (reverse) data['reverse'] = 'true';\n            if (start) data['start'] = start;\n            if (end) data['end'] = end;\n            if (limit) data['count'] = limit;\n\n            data['auth'] = auth_key;\n\n            // Compose URL Parts\n            url = [STD_ORIGIN, 'v1', 'replay', PUBLISH_KEY, SUBSCRIBE_KEY, source, destination];\n\n            // Start (or Stop) Replay!\n            xdr({\n                callback: jsonp,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail() {\n                    callback([0, 'Disconnected']);\n                },\n                url: url,\n                data: _get_url_params(data)\n            });\n        },\n\n        /*\n            PUBNUB.auth('AJFLKAJSDKLA');\n        */\n        'auth': function auth(_auth) {\n            AUTH_KEY = _auth;\n            CONNECT();\n        },\n\n        /*\n            PUBNUB.time(function(time){ });\n        */\n        'time': function time(callback) {\n            var jsonp = jsonp_cb();\n\n            var data = { 'uuid': UUID, 'auth': AUTH_KEY };\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                url: [STD_ORIGIN, 'time', jsonp],\n                success: function success(response) {\n                    callback(response[0]);\n                },\n                fail: function fail() {\n                    callback(0);\n                }\n            });\n        },\n\n        /*\n            PUBNUB.publish({\n                channel : 'my_chat_channel',\n                message : 'hello!'\n            });\n        */\n        'publish': function publish(args, callback) {\n            var msg = args['message'];\n            if (!msg) return _error('Missing Message');\n\n            var callback = callback || args['callback'] || msg['callback'] || function () {},\n                channel = args['channel'] || msg['channel'],\n                auth_key = args['auth_key'] || AUTH_KEY,\n                cipher_key = args['cipher_key'],\n                err = args['error'] || msg['error'] || function () {},\n                post = args['post'] || false,\n                store = 'store_in_history' in args ? args['store_in_history'] : true,\n                jsonp = jsonp_cb(),\n                add_msg = 'push',\n                params,\n                url;\n\n            if (args['prepend']) add_msg = 'unshift';\n\n            if (!channel) return _error('Missing Channel');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            if (msg['getPubnubMessage']) {\n                msg = msg['getPubnubMessage']();\n            }\n\n            // If trying to send Object\n            msg = JSON['stringify'](encrypt(msg, cipher_key));\n\n            // Create URL\n            url = [STD_ORIGIN, 'publish', PUBLISH_KEY, SUBSCRIBE_KEY, 0, encode(channel), jsonp, encode(msg)];\n\n            params = { 'uuid': UUID, 'auth': auth_key };\n\n            if (!store) params['store'] = \"0\";\n\n            if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;\n\n            // Queue Message Send\n            PUB_QUEUE[add_msg]({\n                callback: jsonp,\n                url: url,\n                data: _get_url_params(params),\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                    _publish(1);\n                },\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                    _publish(1);\n                },\n                mode: post ? 'POST' : 'GET'\n            });\n\n            // Send Message\n            _publish();\n        },\n\n        /*\n            PUBNUB.unsubscribe({ channel : 'my_chat' });\n        */\n        'unsubscribe': function unsubscribe(args, callback) {\n            var channel = args['channel'],\n                channel_group = args['channel_group'],\n                auth_key = args['auth_key'] || AUTH_KEY,\n                callback = callback || args['callback'] || function () {},\n                err = args['error'] || function () {};\n\n            TIMETOKEN = 0;\n            SUB_RESTORE = 1; // REVISIT !!!!\n\n            if (channel) {\n\n                // Prepare LeaveChannel(s)\n                var leave_c = map((channel.join ? channel.join(',') : '' + channel).split(','), function (channel) {\n                    if (!CHANNELS[channel]) return;\n                    return channel;\n                }).join(',');\n\n                // Prepare Channel(s)\n                channel = map((channel.join ? channel.join(',') : '' + channel).split(','), function (channel) {\n                    if (!CHANNELS[channel]) return;\n                    return channel + ',' + channel + PRESENCE_SUFFIX;\n                }).join(',');\n\n                // Iterate over Channels\n                each(channel.split(','), function (ch) {\n                    if (!ch) return;\n                    CHANNELS[ch] = 0;\n                    if (ch in STATE) delete STATE[ch];\n                });\n\n                var CB_CALLED = true;\n                if (READY) {\n                    CB_CALLED = SELF['LEAVE'](leave_c, 0, auth_key, callback, err);\n                }\n                if (!CB_CALLED) callback({ action: \"leave\" });\n            }\n\n            if (channel_group) {\n\n                // Prepare channel group(s)\n                var leave_gc = map((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','), function (channel_group) {\n                    if (!CHANNEL_GROUPS[channel_group]) return;\n                    return channel_group;\n                }).join(',');\n\n                // Prepare channel group(s)\n                channel_group = map((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','), function (channel_group) {\n                    if (!CHANNEL_GROUPS[channel_group]) return;\n                    return channel_group + ',' + channel_group + PRESENCE_SUFFIX;\n                }).join(',');\n\n                // Iterate over channel groups\n                each(channel_group.split(','), function (chg) {\n                    if (!chg) return;\n                    CHANNEL_GROUPS[chg] = 0;\n                    if (chg in STATE) delete STATE[chg];\n                });\n\n                var CB_CALLED = true;\n                if (READY) {\n                    CB_CALLED = SELF['LEAVE_GROUP'](leave_gc, 0, auth_key, callback, err);\n                }\n                if (!CB_CALLED) callback({ action: \"leave\" });\n            }\n\n            // Reset Connection if Count Less\n            CONNECT();\n        },\n\n        /*\n            PUBNUB.subscribe({\n                channel  : 'my_chat'\n                callback : function(message) { }\n            });\n        */\n        'subscribe': function subscribe(args, callback) {\n            var channel = args['channel'],\n                channel_group = args['channel_group'],\n                callback = callback || args['callback'],\n                callback = callback || args['message'],\n                connect = args['connect'] || function () {},\n                reconnect = args['reconnect'] || function () {},\n                disconnect = args['disconnect'] || function () {},\n                SUB_ERROR = args['error'] || SUB_ERROR || function () {},\n                idlecb = args['idle'] || function () {},\n                presence = args['presence'] || 0,\n                noheresync = args['noheresync'] || 0,\n                backfill = args['backfill'] || 0,\n                timetoken = args['timetoken'] || 0,\n                sub_timeout = args['timeout'] || SUB_TIMEOUT,\n                windowing = args['windowing'] || SUB_WINDOWING,\n                state = args['state'],\n                heartbeat = args['heartbeat'] || args['pnexpires'],\n                heartbeat_interval = args['heartbeat_interval'],\n                restore = args['restore'] || SUB_RESTORE;\n\n            AUTH_KEY = args['auth_key'] || AUTH_KEY;\n\n            // Restore Enabled?\n            SUB_RESTORE = restore;\n\n            // Always Reset the TT\n            TIMETOKEN = timetoken;\n\n            // Make sure we have a Channel\n            if (!channel && !channel_group) {\n                return _error('Missing Channel');\n            }\n\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            if (heartbeat || heartbeat === 0 || heartbeat_interval || heartbeat_interval === 0) {\n                SELF['set_heartbeat'](heartbeat, heartbeat_interval);\n            }\n\n            // Setup Channel(s)\n            if (channel) {\n                each((channel.join ? channel.join(',') : '' + channel).split(','), function (channel) {\n                    var settings = CHANNELS[channel] || {};\n\n                    // Store Channel State\n                    CHANNELS[SUB_CHANNEL = channel] = {\n                        name: channel,\n                        connected: settings.connected,\n                        disconnected: settings.disconnected,\n                        subscribed: 1,\n                        callback: SUB_CALLBACK = callback,\n                        'cipher_key': args['cipher_key'],\n                        connect: connect,\n                        disconnect: disconnect,\n                        reconnect: reconnect\n                    };\n\n                    if (state) {\n                        if (channel in state) {\n                            STATE[channel] = state[channel];\n                        } else {\n                            STATE[channel] = state;\n                        }\n                    }\n\n                    // Presence Enabled?\n                    if (!presence) return;\n\n                    // Subscribe Presence Channel\n                    SELF['subscribe']({\n                        'channel': channel + PRESENCE_SUFFIX,\n                        'callback': presence,\n                        'restore': restore\n                    });\n\n                    // Presence Subscribed?\n                    if (settings.subscribed) return;\n\n                    // See Who's Here Now?\n                    if (noheresync) return;\n                    SELF['here_now']({\n                        'channel': channel,\n                        'data': _get_url_params({ 'uuid': UUID, 'auth': AUTH_KEY }),\n                        'callback': function callback(here) {\n                            each('uuids' in here ? here['uuids'] : [], function (uid) {\n                                presence({\n                                    'action': 'join',\n                                    'uuid': uid,\n                                    'timestamp': Math.floor(pubNubUtils.rnow() / 1000),\n                                    'occupancy': here['occupancy'] || 1\n                                }, here, channel);\n                            });\n                        }\n                    });\n                });\n            }\n\n            // Setup Channel Groups\n            if (channel_group) {\n                each((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','), function (channel_group) {\n                    var settings = CHANNEL_GROUPS[channel_group] || {};\n\n                    CHANNEL_GROUPS[channel_group] = {\n                        name: channel_group,\n                        connected: settings.connected,\n                        disconnected: settings.disconnected,\n                        subscribed: 1,\n                        callback: SUB_CALLBACK = callback,\n                        'cipher_key': args['cipher_key'],\n                        connect: connect,\n                        disconnect: disconnect,\n                        reconnect: reconnect\n                    };\n\n                    // Presence Enabled?\n                    if (!presence) return;\n\n                    // Subscribe Presence Channel\n                    SELF['subscribe']({\n                        'channel_group': channel_group + PRESENCE_SUFFIX,\n                        'callback': presence,\n                        'restore': restore,\n                        'auth_key': AUTH_KEY\n                    });\n\n                    // Presence Subscribed?\n                    if (settings.subscribed) return;\n\n                    // See Who's Here Now?\n                    if (noheresync) return;\n                    SELF['here_now']({\n                        'channel_group': channel_group,\n                        'data': _get_url_params({ 'uuid': UUID, 'auth': AUTH_KEY }),\n                        'callback': function callback(here) {\n                            each('uuids' in here ? here['uuids'] : [], function (uid) {\n                                presence({\n                                    'action': 'join',\n                                    'uuid': uid,\n                                    'timestamp': Math.floor(rnow() / 1000),\n                                    'occupancy': here['occupancy'] || 1\n                                }, here, channel_group);\n                            });\n                        }\n                    });\n                });\n            }\n\n            // Test Network Connection\n            function _test_connection(success) {\n                if (success) {\n                    // Begin Next Socket Connection\n                    timeout(CONNECT, windowing);\n                } else {\n                    // New Origin on Failed Connection\n                    STD_ORIGIN = nextorigin(ORIGIN, 1);\n                    SUB_ORIGIN = nextorigin(ORIGIN, 1);\n\n                    // Re-test Connection\n                    timeout(function () {\n                        SELF['time'](_test_connection);\n                    }, SECOND);\n                }\n\n                // Disconnect & Reconnect\n                each_channel(function (channel) {\n                    // Reconnect\n                    if (success && channel.disconnected) {\n                        channel.disconnected = 0;\n                        return channel.reconnect(channel.name);\n                    }\n\n                    // Disconnect\n                    if (!success && !channel.disconnected) {\n                        channel.disconnected = 1;\n                        channel.disconnect(channel.name);\n                    }\n                });\n\n                // Disconnect & Reconnect for channel groups\n                each_channel_group(function (channel_group) {\n                    // Reconnect\n                    if (success && channel_group.disconnected) {\n                        channel_group.disconnected = 0;\n                        return channel_group.reconnect(channel_group.name);\n                    }\n\n                    // Disconnect\n                    if (!success && !channel_group.disconnected) {\n                        channel_group.disconnected = 1;\n                        channel_group.disconnect(channel_group.name);\n                    }\n                });\n            }\n\n            // Evented Subscribe\n            function _connect() {\n                var jsonp = jsonp_cb(),\n                    channels = generate_channel_list(CHANNELS).join(','),\n                    channel_groups = generate_channel_group_list(CHANNEL_GROUPS).join(',');\n\n                // Stop Connection\n                if (!channels && !channel_groups) return;\n\n                if (!channels) channels = ',';\n\n                // Connect to PubNub Subscribe Servers\n                _reset_offline();\n\n                var data = _get_url_params({ 'uuid': UUID, 'auth': AUTH_KEY });\n\n                if (channel_groups) {\n                    data['channel-group'] = channel_groups;\n                }\n\n                var st = JSON.stringify(STATE);\n                if (st.length > 2) data['state'] = JSON.stringify(STATE);\n\n                if (PRESENCE_HB) data['heartbeat'] = PRESENCE_HB;\n\n                if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n                start_presence_heartbeat();\n                SUB_RECEIVER = xdr({\n                    timeout: sub_timeout,\n                    callback: jsonp,\n                    fail: function fail(response) {\n                        if (response && response['error'] && response['service']) {\n                            _invoke_error(response, SUB_ERROR);\n                            _test_connection(1);\n                        } else {\n                            SELF['time'](function (success) {\n                                !success && _invoke_error(response, SUB_ERROR);\n                                _test_connection(success);\n                            });\n                        }\n                    },\n                    data: _get_url_params(data),\n                    url: [SUB_ORIGIN, 'subscribe', SUBSCRIBE_KEY, encode(channels), jsonp, TIMETOKEN],\n                    success: function success(messages) {\n\n                        // Check for Errors\n                        if (!messages || (typeof messages === 'undefined' ? 'undefined' : _typeof(messages)) == 'object' && 'error' in messages && messages['error']) {\n                            SUB_ERROR(messages['error']);\n                            return timeout(CONNECT, SECOND);\n                        }\n\n                        // User Idle Callback\n                        idlecb(messages[1]);\n\n                        // Restore Previous Connection Point if Needed\n                        TIMETOKEN = !TIMETOKEN && SUB_RESTORE && db['get'](SUBSCRIBE_KEY) || messages[1];\n\n                        /*\n                        // Connect\n                        each_channel_registry(function(registry){\n                            if (registry.connected) return;\n                            registry.connected = 1;\n                            registry.connect(channel.name);\n                        });\n                        */\n\n                        // Connect\n                        each_channel(function (channel) {\n                            if (channel.connected) return;\n                            channel.connected = 1;\n                            channel.connect(channel.name);\n                        });\n\n                        // Connect for channel groups\n                        each_channel_group(function (channel_group) {\n                            if (channel_group.connected) return;\n                            channel_group.connected = 1;\n                            channel_group.connect(channel_group.name);\n                        });\n\n                        if (RESUMED && !SUB_RESTORE) {\n                            TIMETOKEN = 0;\n                            RESUMED = false;\n                            // Update Saved Timetoken\n                            db['set'](SUBSCRIBE_KEY, 0);\n                            timeout(_connect, windowing);\n                            return;\n                        }\n\n                        // Invoke Memory Catchup and Receive Up to 100\n                        // Previous Messages from the Queue.\n                        if (backfill) {\n                            TIMETOKEN = 10000;\n                            backfill = 0;\n                        }\n\n                        // Update Saved Timetoken\n                        db['set'](SUBSCRIBE_KEY, messages[1]);\n\n                        // Route Channel <---> Callback for Message\n                        var next_callback = (function () {\n                            var channels = '';\n                            var channels2 = '';\n\n                            if (messages.length > 3) {\n                                channels = messages[3];\n                                channels2 = messages[2];\n                            } else if (messages.length > 2) {\n                                channels = messages[2];\n                            } else {\n                                channels = map(generate_channel_list(CHANNELS), function (chan) {\n                                    return map(Array(messages[0].length).join(',').split(','), function () {\n                                        return chan;\n                                    });\n                                }).join(',');\n                            }\n\n                            var list = channels.split(',');\n                            var list2 = channels2 ? channels2.split(',') : [];\n\n                            return function () {\n                                var channel = list.shift() || SUB_CHANNEL;\n                                var channel2 = list2.shift();\n\n                                var chobj = {};\n\n                                if (channel2) {\n                                    if (channel && channel.indexOf('-pnpres') >= 0 && channel2.indexOf('-pnpres') < 0) {\n                                        channel2 += '-pnpres';\n                                    }\n                                    chobj = CHANNEL_GROUPS[channel2] || CHANNELS[channel2] || { 'callback': function callback() {} };\n                                } else {\n                                    chobj = CHANNELS[channel];\n                                }\n\n                                var r = [chobj.callback || SUB_CALLBACK, channel.split(PRESENCE_SUFFIX)[0]];\n                                channel2 && r.push(channel2.split(PRESENCE_SUFFIX)[0]);\n                                return r;\n                            };\n                        })();\n\n                        var latency = detect_latency(+messages[1]);\n                        each(messages[0], function (msg) {\n                            var next = next_callback();\n                            var decrypted_msg = decrypt(msg, CHANNELS[next[1]] ? CHANNELS[next[1]]['cipher_key'] : null);\n                            next[0] && next[0](decrypted_msg, messages, next[2] || next[1], latency, next[1]);\n                        });\n\n                        timeout(_connect, windowing);\n                    }\n                });\n            }\n\n            CONNECT = function () {\n                _reset_offline();\n                timeout(_connect, windowing);\n            };\n\n            // Reduce Status Flicker\n            if (!READY) return READY_BUFFER.push(CONNECT);\n\n            // Connect Now\n            CONNECT();\n        },\n\n        /*\n            PUBNUB.here_now({ channel : 'my_chat', callback : fun });\n        */\n        'here_now': function here_now(args, callback) {\n            var callback = args['callback'] || callback,\n                debug = args['debug'],\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                jsonp = jsonp_cb(),\n                uuids = 'uuids' in args ? args['uuids'] : true,\n                state = args['state'],\n                data = { 'uuid': UUID, 'auth': auth_key };\n\n            if (!uuids) data['disable_uuids'] = 1;\n            if (state) data['state'] = 1;\n\n            // Make sure we have a Channel\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            var url = [STD_ORIGIN, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY];\n\n            channel && url.push('channel') && url.push(encode(channel));\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            if (channel_group) {\n                data['channel-group'] = channel_group;\n                !channel && url.push('channel') && url.push(',');\n            }\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                debug: debug,\n                url: url\n            });\n        },\n\n        /*\n            PUBNUB.current_channels_by_uuid({ channel : 'my_chat', callback : fun });\n        */\n        'where_now': function where_now(args, callback) {\n            var callback = args['callback'] || callback,\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                jsonp = jsonp_cb(),\n                uuid = args['uuid'] || UUID,\n                data = { 'auth': auth_key };\n\n            // Make sure we have a Channel\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v2', 'presence', 'sub_key', SUBSCRIBE_KEY, 'uuid', encode(uuid)]\n            });\n        },\n\n        'state': function state(args, callback) {\n            var callback = args['callback'] || callback || function (r) {},\n                err = args['error'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                jsonp = jsonp_cb(),\n                state = args['state'],\n                uuid = args['uuid'] || UUID,\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                url,\n                data = _get_url_params({ 'auth': auth_key });\n\n            // Make sure we have a Channel\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n            if (!uuid) return _error('Missing UUID');\n            if (!channel && !channel_group) return _error('Missing Channel');\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            if (typeof channel != 'undefined' && CHANNELS[channel] && CHANNELS[channel].subscribed) {\n                if (state) STATE[channel] = state;\n            }\n\n            if (typeof channel_group != 'undefined' && CHANNEL_GROUPS[channel_group] && CHANNEL_GROUPS[channel_group].subscribed) {\n                if (state) STATE[channel_group] = state;\n                data['channel-group'] = channel_group;\n\n                if (!channel) {\n                    channel = ',';\n                }\n            }\n\n            data['state'] = JSON.stringify(state);\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            if (state) {\n                url = [STD_ORIGIN, 'v2', 'presence', 'sub-key', SUBSCRIBE_KEY, 'channel', channel, 'uuid', uuid, 'data'];\n            } else {\n                url = [STD_ORIGIN, 'v2', 'presence', 'sub-key', SUBSCRIBE_KEY, 'channel', channel, 'uuid', encode(uuid)];\n            }\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n\n            });\n        },\n\n        /*\n            PUBNUB.grant({\n                channel  : 'my_chat',\n                callback : fun,\n                error    : fun,\n                ttl      : 24 * 60, // Minutes\n                read     : true,\n                write    : true,\n                auth_key : '3y8uiajdklytowsj'\n            });\n        */\n        'grant': function grant(args, callback) {\n            var callback = args['callback'] || callback,\n                err = args['error'] || function () {},\n                channel = args['channel'] || args['channels'],\n                channel_group = args['channel_group'],\n                jsonp = jsonp_cb(),\n                ttl = args['ttl'],\n                r = args['read'] ? \"1\" : \"0\",\n                w = args['write'] ? \"1\" : \"0\",\n                m = args['manage'] ? \"1\" : \"0\",\n                auth_key = args['auth_key'] || args['auth_keys'];\n\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SECRET_KEY) return _error('Missing Secret Key');\n\n            var timestamp = Math.floor(new Date().getTime() / 1000),\n                sign_input = SUBSCRIBE_KEY + \"\\n\" + PUBLISH_KEY + \"\\n\" + \"grant\" + \"\\n\";\n\n            var data = {\n                'w': w,\n                'r': r,\n                'timestamp': timestamp\n            };\n            if (args['manage']) {\n                data['m'] = m;\n            }\n            if (isArray(channel)) {\n                channel = channel['join'](',');\n            }\n            if (isArray(auth_key)) {\n                auth_key = auth_key['join'](',');\n            }\n            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n                data['channel-group'] = channel_group;\n            }\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n            if (ttl || ttl === 0) data['ttl'] = ttl;\n\n            if (auth_key) data['auth'] = auth_key;\n\n            data = _get_url_params(data);\n\n            if (!auth_key) delete data['auth'];\n\n            sign_input += _get_pam_sign_input_from_params(data);\n\n            var signature = hmac_SHA256(sign_input, SECRET_KEY);\n\n            signature = signature.replace(/\\+/g, \"-\");\n            signature = signature.replace(/\\//g, \"_\");\n\n            data['signature'] = signature;\n\n            xdr({\n                callback: jsonp,\n                data: data,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v1', 'auth', 'grant', 'sub-key', SUBSCRIBE_KEY]\n            });\n        },\n\n        /*\n         PUBNUB.mobile_gw_provision ({\n         device_id: 'A655FBA9931AB',\n         op       : 'add' | 'remove',\n         gw_type  : 'apns' | 'gcm',\n         channel  : 'my_chat',\n         callback : fun,\n         error    : fun,\n         });\n         */\n\n        'mobile_gw_provision': function mobile_gw_provision(args) {\n\n            var callback = args['callback'] || function () {},\n                auth_key = args['auth_key'] || AUTH_KEY,\n                err = args['error'] || function () {},\n                jsonp = jsonp_cb(),\n                channel = args['channel'],\n                op = args['op'],\n                gw_type = args['gw_type'],\n                device_id = args['device_id'],\n                params,\n                url;\n\n            if (!device_id) return _error('Missing Device ID (device_id)');\n            if (!gw_type) return _error('Missing GW Type (gw_type: gcm or apns)');\n            if (!op) return _error('Missing GW Operation (op: add or remove)');\n            if (!channel) return _error('Missing gw destination Channel (channel)');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n\n            // Create URL\n            url = [STD_ORIGIN, 'v1/push/sub-key', SUBSCRIBE_KEY, 'devices', device_id];\n\n            params = { 'uuid': UUID, 'auth': auth_key, 'type': gw_type };\n\n            if (op == \"add\") {\n                params['add'] = channel;\n            } else if (op == \"remove\") {\n                params['remove'] = channel;\n            }\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: params,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: url\n            });\n        },\n\n        /*\n            PUBNUB.audit({\n                channel  : 'my_chat',\n                callback : fun,\n                error    : fun,\n                read     : true,\n                write    : true,\n                auth_key : '3y8uiajdklytowsj'\n            });\n        */\n        'audit': function audit(args, callback) {\n            var callback = args['callback'] || callback,\n                err = args['error'] || function () {},\n                channel = args['channel'],\n                channel_group = args['channel_group'],\n                auth_key = args['auth_key'],\n                jsonp = jsonp_cb();\n\n            // Make sure we have a Channel\n            if (!callback) return _error('Missing Callback');\n            if (!SUBSCRIBE_KEY) return _error('Missing Subscribe Key');\n            if (!PUBLISH_KEY) return _error('Missing Publish Key');\n            if (!SECRET_KEY) return _error('Missing Secret Key');\n\n            var timestamp = Math.floor(new Date().getTime() / 1000),\n                sign_input = SUBSCRIBE_KEY + \"\\n\" + PUBLISH_KEY + \"\\n\" + \"audit\" + \"\\n\";\n\n            var data = { 'timestamp': timestamp };\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n            if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;\n            if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {\n                data['channel-group'] = channel_group;\n            }\n            if (auth_key) data['auth'] = auth_key;\n\n            data = _get_url_params(data);\n\n            if (!auth_key) delete data['auth'];\n\n            sign_input += _get_pam_sign_input_from_params(data);\n\n            var signature = hmac_SHA256(sign_input, SECRET_KEY);\n\n            signature = signature.replace(/\\+/g, \"-\");\n            signature = signature.replace(/\\//g, \"_\");\n\n            data['signature'] = signature;\n            xdr({\n                callback: jsonp,\n                data: data,\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                },\n                url: [STD_ORIGIN, 'v1', 'auth', 'audit', 'sub-key', SUBSCRIBE_KEY]\n            });\n        },\n\n        /*\n            PUBNUB.revoke({\n                channel  : 'my_chat',\n                callback : fun,\n                error    : fun,\n                auth_key : '3y8uiajdklytowsj'\n            });\n        */\n        'revoke': function revoke(args, callback) {\n            args['read'] = false;\n            args['write'] = false;\n            SELF['grant'](args, callback);\n        },\n        'set_uuid': function set_uuid(uuid) {\n            UUID = uuid;\n            CONNECT();\n        },\n        'get_uuid': function get_uuid() {\n            return UUID;\n        },\n        'isArray': (function (_isArray) {\n            function isArray(_x) {\n                return _isArray.apply(this, arguments);\n            }\n\n            isArray.toString = function () {\n                return _isArray.toString();\n            };\n\n            return isArray;\n        })(function (arg) {\n            return isArray(arg);\n        }),\n        'get_subscibed_channels': function get_subscibed_channels() {\n            return generate_channel_list(CHANNELS, true);\n        },\n        'presence_heartbeat': function presence_heartbeat(args) {\n            var callback = args['callback'] || function () {};\n            var err = args['error'] || function () {};\n            var jsonp = jsonp_cb();\n            var data = { 'uuid': UUID, 'auth': AUTH_KEY };\n\n            var st = JSON['stringify'](STATE);\n            if (st.length > 2) data['state'] = JSON['stringify'](STATE);\n\n            if (PRESENCE_HB > 0 && PRESENCE_HB < 320) data['heartbeat'] = PRESENCE_HB;\n\n            if (jsonp != '0') {\n                data['callback'] = jsonp;\n            }\n\n            var channels = encode(generate_channel_list(CHANNELS, true)['join'](','));\n            var channel_groups = generate_channel_group_list(CHANNEL_GROUPS, true)['join'](',');\n\n            if (!channels) channels = ',';\n            if (channel_groups) data['channel-group'] = channel_groups;\n\n            if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;\n\n            xdr({\n                callback: jsonp,\n                data: _get_url_params(data),\n                url: [STD_ORIGIN, 'v2', 'presence', 'sub-key', SUBSCRIBE_KEY, 'channel', channels, 'heartbeat'],\n                success: function success(response) {\n                    _invoke_callback(response, callback, err);\n                },\n                fail: function fail(response) {\n                    _invoke_error(response, err);\n                }\n            });\n        },\n        'stop_timers': function stop_timers() {\n            clearTimeout(_poll_timer);\n            clearTimeout(_poll_timer2);\n            clearTimeout(PRESENCE_HB_TIMEOUT);\n        },\n        'shutdown': function shutdown() {\n            SELF['stop_timers']();\n            _shutdown && _shutdown();\n        },\n\n        // Expose PUBNUB Functions\n        'xdr': xdr,\n        'ready': ready,\n        'db': db,\n        'uuid': generate_uuid,\n        'map': map,\n        'each': each,\n        'each-channel': each_channel,\n        'grep': grep,\n        'offline': function offline() {\n            _reset_offline(1, { \"message\": \"Offline. Please check your network settings.\" });\n        },\n        'supplant': supplant,\n        'now': rnow,\n        'unique': unique,\n        'updater': updater\n    };\n\n    function _poll_online() {\n        _is_online() || _reset_offline(1, {\n            \"error\": \"Offline. Please check your network settings. \"\n        });\n        _poll_timer && clearTimeout(_poll_timer);\n        _poll_timer = timeout(_poll_online, SECOND);\n    }\n\n    function _poll_online2() {\n        if (!TIME_CHECK) return;\n        SELF['time'](function (success) {\n            detect_time_detla(function () {}, success);\n            success || _reset_offline(1, {\n                \"error\": \"Heartbeat failed to connect to Pubnub Servers.\" + \"Please check your network settings.\"\n            });\n            _poll_timer2 && clearTimeout(_poll_timer2);\n            _poll_timer2 = timeout(_poll_online2, KEEPALIVE);\n        });\n    }\n\n    function _reset_offline(err, msg) {\n        SUB_RECEIVER && SUB_RECEIVER(err, msg);\n        SUB_RECEIVER = null;\n\n        clearTimeout(_poll_timer);\n        clearTimeout(_poll_timer2);\n    }\n\n    if (!UUID) UUID = SELF['uuid']();\n    if (!INSTANCEID) INSTANCEID = SELF['uuid']();\n    db['set'](SUBSCRIBE_KEY + 'uuid', UUID);\n\n    _poll_timer = timeout(_poll_online, SECOND);\n    _poll_timer2 = timeout(_poll_online2, KEEPALIVE);\n    PRESENCE_HB_TIMEOUT = timeout(start_presence_heartbeat, (PRESENCE_HB_INTERVAL - 3) * SECOND);\n\n    // Detect Age of Message\n    function detect_latency(tt) {\n        var adjusted_time = rnow() - TIME_DRIFT;\n        return adjusted_time - tt / 10000;\n    }\n\n    detect_time_detla();\n    function detect_time_detla(cb, time) {\n        var stime = rnow();\n\n        time && calculate(time) || SELF['time'](calculate);\n\n        function calculate(time) {\n            if (!time) return;\n            var ptime = time / 10000,\n                latency = (pubNubUtils.rnow() - stime) / 2;\n            TIME_DRIFT = pubNubUtils.rnow() - (ptime + latency);\n            cb && cb(TIME_DRIFT);\n        }\n    }\n\n    return SELF;\n}\n},{\"./utils\":2}],2:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unique = unique;\nexports.rnow = rnow;\nexports.generateUUID = generateUUID;\nexports.updater = updater;\nexports.buildURL = buildURL;\nexports.supplant = supplant;\nexports.sugarTimeout = sugarTimeout;\nexports.nextOrigin = nextOrigin;\n\nvar _uuid = require('uuid');\n\nvar uuid = _interopRequireWildcard(_uuid);\n\nvar _forEach = require('lodash/collection/forEach');\n\nvar _forEach2 = _interopRequireDefault(_forEach);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _typeof(obj) { return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }\n\n/*\n    TODO: I have no idea how those origins are chosen, I suspect there might be a serious collision problems\n\n\n    grep ====>>> _.filter\n */\n\nvar maxOrigin = 20;\nvar URLBIT = '/';\nvar PARAMSBIT = '&';\nvar REPL = /{([\\w\\-]+)}/g;\n\nvar NOW = 1;\nvar chosenOrigin = Math.floor(Math.random() * maxOrigin);\n\nfunction encode(path) {\n  return encodeURIComponent(path);\n}\n\nfunction unique() {\n  return 'x' + ++NOW + '' + +new Date();\n}\n\nfunction rnow() {\n  return +new Date();\n}\n\nfunction generateUUID(callback) {\n  var u = uuid.v4();\n\n  if (callback) {\n    callback(u);\n  }\n\n  return u;\n}\n\nfunction updater(fun, rate) {\n  var timeout = null;\n  var last = 0;\n\n  function runnit() {\n    if (last + rate > rnow()) {\n      clearTimeout(timeout);\n      timeout = setTimeout(runnit, rate);\n    } else {\n      last = rnow();\n      fun();\n    }\n  }\n\n  return runnit;\n}\n\nfunction buildURL(urlComponents, urlParams) {\n  var url = urlComponents.join(URLBIT);\n  var params = [];\n\n  if (!urlParams) {\n    return url;\n  }\n\n  (0, _forEach2.default)(urlParams, function (key, value) {\n    var valueStr = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? JSON.stringify(value) : value;\n\n    if (typeof value !== 'undefined' && value !== null && encode(valueStr).length > 0) {\n      params.push(key + '=' + encode(valueStr));\n    }\n  });\n\n  url += '?' + params.join(PARAMSBIT);\n  return url;\n}\n\nfunction supplant(str, values) {\n  return str.replace(REPL, function (_, match) {\n    return values[match] || _;\n  });\n}\n\nfunction sugarTimeout(fun, wait) {\n  return setTimeout(fun, wait);\n}\n\n/* TODO: i have no idea what this function does */\nfunction nextOrigin(origin, failOver) {\n  // do not operate on non pubsub domains\n  if (origin.indexOf('pubsub.') < 0) {\n    return null;\n  }\n\n  var selectedOrigin = undefined;\n\n  // we need to settle on a new origin\n  if (failOver !== null) {\n    selectedOrigin = failOver;\n  } else {\n    // bump up the chosenOrigin\n    chosenOrigin = chosenOrigin + 1;\n\n    if (chosenOrigin > maxOrigin) {\n      chosenOrigin = 1;\n    }\n\n    selectedOrigin = chosenOrigin;\n  }\n\n  return origin.replace('pubsub', 'ps' + selectedOrigin);\n}\n},{\"lodash/collection/forEach\":3,\"uuid\":30}],3:[function(require,module,exports){\nvar arrayEach = require('../internal/arrayEach'),\n    baseEach = require('../internal/baseEach'),\n    createForEach = require('../internal/createForEach');\n\n/**\n * Iterates over elements of `collection` invoking `iteratee` for each element.\n * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n * (value, index|key, collection). Iteratee functions may exit iteration early\n * by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\" property\n * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n * may be used for object iteration.\n *\n * @static\n * @memberOf _\n * @alias each\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {Array|Object|string} Returns `collection`.\n * @example\n *\n * _([1, 2]).forEach(function(n) {\n *   console.log(n);\n * }).value();\n * // => logs each value from left to right and returns the array\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {\n *   console.log(n, key);\n * });\n * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\n */\nvar forEach = createForEach(arrayEach, baseEach);\n\nmodule.exports = forEach;\n\n},{\"../internal/arrayEach\":4,\"../internal/baseEach\":5,\"../internal/createForEach\":12}],4:[function(require,module,exports){\n/**\n * A specialized version of `_.forEach` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n\n},{}],5:[function(require,module,exports){\nvar baseForOwn = require('./baseForOwn'),\n    createBaseEach = require('./createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object|string} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n\n},{\"./baseForOwn\":7,\"./createBaseEach\":10}],6:[function(require,module,exports){\nvar createBaseFor = require('./createBaseFor');\n\n/**\n * The base implementation of `baseForIn` and `baseForOwn` which iterates\n * over `object` properties returned by `keysFunc` invoking `iteratee` for\n * each property. Iteratee functions may exit iteration early by explicitly\n * returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n\n},{\"./createBaseFor\":11}],7:[function(require,module,exports){\nvar baseFor = require('./baseFor'),\n    keys = require('../object/keys');\n\n/**\n * The base implementation of `_.forOwn` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n\n},{\"../object/keys\":26,\"./baseFor\":6}],8:[function(require,module,exports){\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n\n},{}],9:[function(require,module,exports){\nvar identity = require('../utility/identity');\n\n/**\n * A specialized version of `baseCallback` which only supports `this` binding\n * and specifying the number of arguments to provide to `func`.\n *\n * @private\n * @param {Function} func The function to bind.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {number} [argCount] The number of arguments to provide to `func`.\n * @returns {Function} Returns the callback.\n */\nfunction bindCallback(func, thisArg, argCount) {\n  if (typeof func != 'function') {\n    return identity;\n  }\n  if (thisArg === undefined) {\n    return func;\n  }\n  switch (argCount) {\n    case 1: return function(value) {\n      return func.call(thisArg, value);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(thisArg, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(thisArg, accumulator, value, index, collection);\n    };\n    case 5: return function(value, other, key, object, source) {\n      return func.call(thisArg, value, other, key, object, source);\n    };\n  }\n  return function() {\n    return func.apply(thisArg, arguments);\n  };\n}\n\nmodule.exports = bindCallback;\n\n},{\"../utility/identity\":28}],10:[function(require,module,exports){\nvar getLength = require('./getLength'),\n    isLength = require('./isLength'),\n    toObject = require('./toObject');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    var length = collection ? getLength(collection) : 0;\n    if (!isLength(length)) {\n      return eachFunc(collection, iteratee);\n    }\n    var index = fromRight ? length : -1,\n        iterable = toObject(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n\n},{\"./getLength\":13,\"./isLength\":17,\"./toObject\":20}],11:[function(require,module,exports){\nvar toObject = require('./toObject');\n\n/**\n * Creates a base function for `_.forIn` or `_.forInRight`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var iterable = toObject(object),\n        props = keysFunc(object),\n        length = props.length,\n        index = fromRight ? length : -1;\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var key = props[index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n\n},{\"./toObject\":20}],12:[function(require,module,exports){\nvar bindCallback = require('./bindCallback'),\n    isArray = require('../lang/isArray');\n\n/**\n * Creates a function for `_.forEach` or `_.forEachRight`.\n *\n * @private\n * @param {Function} arrayFunc The function to iterate over an array.\n * @param {Function} eachFunc The function to iterate over a collection.\n * @returns {Function} Returns the new each function.\n */\nfunction createForEach(arrayFunc, eachFunc) {\n  return function(collection, iteratee, thisArg) {\n    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n      ? arrayFunc(collection, iteratee)\n      : eachFunc(collection, bindCallback(iteratee, thisArg, 3));\n  };\n}\n\nmodule.exports = createForEach;\n\n},{\"../lang/isArray\":22,\"./bindCallback\":9}],13:[function(require,module,exports){\nvar baseProperty = require('./baseProperty');\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\nmodule.exports = getLength;\n\n},{\"./baseProperty\":8}],14:[function(require,module,exports){\nvar isNative = require('../lang/isNative');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n},{\"../lang/isNative\":24}],15:[function(require,module,exports){\nvar getLength = require('./getLength'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\nmodule.exports = isArrayLike;\n\n},{\"./getLength\":13,\"./isLength\":17}],16:[function(require,module,exports){\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^\\d+$/;\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\nmodule.exports = isIndex;\n\n},{}],17:[function(require,module,exports){\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n},{}],18:[function(require,module,exports){\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n},{}],19:[function(require,module,exports){\nvar isArguments = require('../lang/isArguments'),\n    isArray = require('../lang/isArray'),\n    isIndex = require('./isIndex'),\n    isLength = require('./isLength'),\n    keysIn = require('../object/keysIn');\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A fallback implementation of `Object.keys` which creates an array of the\n * own enumerable property names of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction shimKeys(object) {\n  var props = keysIn(object),\n      propsLength = props.length,\n      length = propsLength && object.length;\n\n  var allowIndexes = !!length && isLength(length) &&\n    (isArray(object) || isArguments(object));\n\n  var index = -1,\n      result = [];\n\n  while (++index < propsLength) {\n    var key = props[index];\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = shimKeys;\n\n},{\"../lang/isArguments\":21,\"../lang/isArray\":22,\"../object/keysIn\":27,\"./isIndex\":16,\"./isLength\":17}],20:[function(require,module,exports){\nvar isObject = require('../lang/isObject');\n\n/**\n * Converts `value` to an object if it's not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Object} Returns the object.\n */\nfunction toObject(value) {\n  return isObject(value) ? value : Object(value);\n}\n\nmodule.exports = toObject;\n\n},{\"../lang/isObject\":25}],21:[function(require,module,exports){\nvar isArrayLike = require('../internal/isArrayLike'),\n    isObjectLike = require('../internal/isObjectLike');\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Native method references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is classified as an `arguments` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  return isObjectLike(value) && isArrayLike(value) &&\n    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n}\n\nmodule.exports = isArguments;\n\n},{\"../internal/isArrayLike\":15,\"../internal/isObjectLike\":18}],22:[function(require,module,exports){\nvar getNative = require('../internal/getNative'),\n    isLength = require('../internal/isLength'),\n    isObjectLike = require('../internal/isObjectLike');\n\n/** `Object#toString` result references. */\nvar arrayTag = '[object Array]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeIsArray = getNative(Array, 'isArray');\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(function() { return arguments; }());\n * // => false\n */\nvar isArray = nativeIsArray || function(value) {\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n};\n\nmodule.exports = isArray;\n\n},{\"../internal/getNative\":14,\"../internal/isLength\":17,\"../internal/isObjectLike\":18}],23:[function(require,module,exports){\nvar isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in older versions of Chrome and Safari which return 'function' for regexes\n  // and Safari 8 which returns 'object' for typed array constructors.\n  return isObject(value) && objToString.call(value) == funcTag;\n}\n\nmodule.exports = isFunction;\n\n},{\"./isObject\":25}],24:[function(require,module,exports){\nvar isFunction = require('./isFunction'),\n    isObjectLike = require('../internal/isObjectLike');\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (isFunction(value)) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = isNative;\n\n},{\"../internal/isObjectLike\":18,\"./isFunction\":23}],25:[function(require,module,exports){\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n},{}],26:[function(require,module,exports){\nvar getNative = require('../internal/getNative'),\n    isArrayLike = require('../internal/isArrayLike'),\n    isObject = require('../lang/isObject'),\n    shimKeys = require('../internal/shimKeys');\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = getNative(Object, 'keys');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nvar keys = !nativeKeys ? shimKeys : function(object) {\n  var Ctor = object == null ? undefined : object.constructor;\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n      (typeof object != 'function' && isArrayLike(object))) {\n    return shimKeys(object);\n  }\n  return isObject(object) ? nativeKeys(object) : [];\n};\n\nmodule.exports = keys;\n\n},{\"../internal/getNative\":14,\"../internal/isArrayLike\":15,\"../internal/shimKeys\":19,\"../lang/isObject\":25}],27:[function(require,module,exports){\nvar isArguments = require('../lang/isArguments'),\n    isArray = require('../lang/isArray'),\n    isIndex = require('../internal/isIndex'),\n    isLength = require('../internal/isLength'),\n    isObject = require('../lang/isObject');\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  if (object == null) {\n    return [];\n  }\n  if (!isObject(object)) {\n    object = Object(object);\n  }\n  var length = object.length;\n  length = (length && isLength(length) &&\n    (isArray(object) || isArguments(object)) && length) || 0;\n\n  var Ctor = object.constructor,\n      index = -1,\n      isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n      result = Array(length),\n      skipIndexes = length > 0;\n\n  while (++index < length) {\n    result[index] = (index + '');\n  }\n  for (var key in object) {\n    if (!(skipIndexes && isIndex(key, length)) &&\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = keysIn;\n\n},{\"../internal/isIndex\":16,\"../internal/isLength\":17,\"../lang/isArguments\":21,\"../lang/isArray\":22,\"../lang/isObject\":25}],28:[function(require,module,exports){\n/**\n * This method returns the first argument provided to it.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'user': 'fred' };\n *\n * _.identity(object) === object;\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n\n},{}],29:[function(require,module,exports){\n(function (global){\n\nvar rng;\n\nif (global.crypto && crypto.getRandomValues) {\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // Moderately fast, high quality\n  var _rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(_rnds8);\n    return _rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  _rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return _rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],30:[function(require,module,exports){\n//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = require('./rng');\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\n// **`parse()` - Parse a UUID into it's component bytes**\nfunction parse(s, buf, offset) {\n  var i = (buf && offset) || 0, ii = 0;\n\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n    if (ii < 16) { // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\n// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\nfunction unparse(buf, offset) {\n  var i = offset || 0, bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; n++) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : unparse(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ii++) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || unparse(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nuuid.parse = parse;\nuuid.unparse = unparse;\n\nmodule.exports = uuid;\n\n},{\"./rng\":29}]},{},[1])\n\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unique = unique;\nexports.rnow = rnow;\nexports.generateUUID = generateUUID;\nexports.updater = updater;\nexports.buildURL = buildURL;\nexports.supplant = supplant;\nexports.sugarTimeout = sugarTimeout;\nexports.nextOrigin = nextOrigin;\n\nvar _uuid = require('uuid');\n\nvar uuid = _interopRequireWildcard(_uuid);\n\nvar _forEach = require('lodash/collection/forEach');\n\nvar _forEach2 = _interopRequireDefault(_forEach);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _typeof(obj) { return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }\n\n/*\n    TODO: I have no idea how those origins are chosen, I suspect there might be a serious collision problems\n\n\n    grep ====>>> _.filter\n */\n\nvar maxOrigin = 20;\nvar URLBIT = '/';\nvar PARAMSBIT = '&';\nvar REPL = /{([\\w\\-]+)}/g;\n\nvar NOW = 1;\nvar chosenOrigin = Math.floor(Math.random() * maxOrigin);\n\nfunction encode(path) {\n  return encodeURIComponent(path);\n}\n\nfunction unique() {\n  return 'x' + ++NOW + '' + +new Date();\n}\n\nfunction rnow() {\n  return +new Date();\n}\n\nfunction generateUUID(callback) {\n  var u = uuid.v4();\n\n  if (callback) {\n    callback(u);\n  }\n\n  return u;\n}\n\nfunction updater(fun, rate) {\n  var timeout = null;\n  var last = 0;\n\n  function runnit() {\n    if (last + rate > rnow()) {\n      clearTimeout(timeout);\n      timeout = setTimeout(runnit, rate);\n    } else {\n      last = rnow();\n      fun();\n    }\n  }\n\n  return runnit;\n}\n\nfunction buildURL(urlComponents, urlParams) {\n  var url = urlComponents.join(URLBIT);\n  var params = [];\n\n  if (!urlParams) {\n    return url;\n  }\n\n  (0, _forEach2.default)(urlParams, function (key, value) {\n    var valueStr = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? JSON.stringify(value) : value;\n\n    if (typeof value !== 'undefined' && value !== null && encode(valueStr).length > 0) {\n      params.push(key + '=' + encode(valueStr));\n    }\n  });\n\n  url += '?' + params.join(PARAMSBIT);\n  return url;\n}\n\nfunction supplant(str, values) {\n  return str.replace(REPL, function (_, match) {\n    return values[match] || _;\n  });\n}\n\nfunction sugarTimeout(fun, wait) {\n  return setTimeout(fun, wait);\n}\n\n/* TODO: i have no idea what this function does */\nfunction nextOrigin(origin, failOver) {\n  // do not operate on non pubsub domains\n  if (origin.indexOf('pubsub.') < 0) {\n    return null;\n  }\n\n  var selectedOrigin = undefined;\n\n  // we need to settle on a new origin\n  if (failOver !== null) {\n    selectedOrigin = failOver;\n  } else {\n    // bump up the chosenOrigin\n    chosenOrigin = chosenOrigin + 1;\n\n    if (chosenOrigin > maxOrigin) {\n      chosenOrigin = 1;\n    }\n\n    selectedOrigin = chosenOrigin;\n  }\n\n  return origin.replace('pubsub', 'ps' + selectedOrigin);\n}","var arrayEach = require('../internal/arrayEach'),\n    baseEach = require('../internal/baseEach'),\n    createForEach = require('../internal/createForEach');\n\n/**\n * Iterates over elements of `collection` invoking `iteratee` for each element.\n * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n * (value, index|key, collection). Iteratee functions may exit iteration early\n * by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\" property\n * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n * may be used for object iteration.\n *\n * @static\n * @memberOf _\n * @alias each\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {Array|Object|string} Returns `collection`.\n * @example\n *\n * _([1, 2]).forEach(function(n) {\n *   console.log(n);\n * }).value();\n * // => logs each value from left to right and returns the array\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {\n *   console.log(n, key);\n * });\n * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\n */\nvar forEach = createForEach(arrayEach, baseEach);\n\nmodule.exports = forEach;\n","/**\n * A specialized version of `_.forEach` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","var baseForOwn = require('./baseForOwn'),\n    createBaseEach = require('./createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object|string} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n","var createBaseFor = require('./createBaseFor');\n\n/**\n * The base implementation of `baseForIn` and `baseForOwn` which iterates\n * over `object` properties returned by `keysFunc` invoking `iteratee` for\n * each property. Iteratee functions may exit iteration early by explicitly\n * returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","var baseFor = require('./baseFor'),\n    keys = require('../object/keys');\n\n/**\n * The base implementation of `_.forOwn` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n","var identity = require('../utility/identity');\n\n/**\n * A specialized version of `baseCallback` which only supports `this` binding\n * and specifying the number of arguments to provide to `func`.\n *\n * @private\n * @param {Function} func The function to bind.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {number} [argCount] The number of arguments to provide to `func`.\n * @returns {Function} Returns the callback.\n */\nfunction bindCallback(func, thisArg, argCount) {\n  if (typeof func != 'function') {\n    return identity;\n  }\n  if (thisArg === undefined) {\n    return func;\n  }\n  switch (argCount) {\n    case 1: return function(value) {\n      return func.call(thisArg, value);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(thisArg, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(thisArg, accumulator, value, index, collection);\n    };\n    case 5: return function(value, other, key, object, source) {\n      return func.call(thisArg, value, other, key, object, source);\n    };\n  }\n  return function() {\n    return func.apply(thisArg, arguments);\n  };\n}\n\nmodule.exports = bindCallback;\n","var getLength = require('./getLength'),\n    isLength = require('./isLength'),\n    toObject = require('./toObject');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    var length = collection ? getLength(collection) : 0;\n    if (!isLength(length)) {\n      return eachFunc(collection, iteratee);\n    }\n    var index = fromRight ? length : -1,\n        iterable = toObject(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n","var toObject = require('./toObject');\n\n/**\n * Creates a base function for `_.forIn` or `_.forInRight`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var iterable = toObject(object),\n        props = keysFunc(object),\n        length = props.length,\n        index = fromRight ? length : -1;\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var key = props[index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var bindCallback = require('./bindCallback'),\n    isArray = require('../lang/isArray');\n\n/**\n * Creates a function for `_.forEach` or `_.forEachRight`.\n *\n * @private\n * @param {Function} arrayFunc The function to iterate over an array.\n * @param {Function} eachFunc The function to iterate over a collection.\n * @returns {Function} Returns the new each function.\n */\nfunction createForEach(arrayFunc, eachFunc) {\n  return function(collection, iteratee, thisArg) {\n    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n      ? arrayFunc(collection, iteratee)\n      : eachFunc(collection, bindCallback(iteratee, thisArg, 3));\n  };\n}\n\nmodule.exports = createForEach;\n","var baseProperty = require('./baseProperty');\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\nmodule.exports = getLength;\n","var isNative = require('../lang/isNative');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var getLength = require('./getLength'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\nmodule.exports = isArrayLike;\n","/** Used to detect unsigned integer values. */\nvar reIsUint = /^\\d+$/;\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\nmodule.exports = isIndex;\n","/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var isArguments = require('../lang/isArguments'),\n    isArray = require('../lang/isArray'),\n    isIndex = require('./isIndex'),\n    isLength = require('./isLength'),\n    keysIn = require('../object/keysIn');\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A fallback implementation of `Object.keys` which creates an array of the\n * own enumerable property names of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction shimKeys(object) {\n  var props = keysIn(object),\n      propsLength = props.length,\n      length = propsLength && object.length;\n\n  var allowIndexes = !!length && isLength(length) &&\n    (isArray(object) || isArguments(object));\n\n  var index = -1,\n      result = [];\n\n  while (++index < propsLength) {\n    var key = props[index];\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = shimKeys;\n","var isObject = require('../lang/isObject');\n\n/**\n * Converts `value` to an object if it's not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Object} Returns the object.\n */\nfunction toObject(value) {\n  return isObject(value) ? value : Object(value);\n}\n\nmodule.exports = toObject;\n","var isArrayLike = require('../internal/isArrayLike'),\n    isObjectLike = require('../internal/isObjectLike');\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Native method references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is classified as an `arguments` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  return isObjectLike(value) && isArrayLike(value) &&\n    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n}\n\nmodule.exports = isArguments;\n","var getNative = require('../internal/getNative'),\n    isLength = require('../internal/isLength'),\n    isObjectLike = require('../internal/isObjectLike');\n\n/** `Object#toString` result references. */\nvar arrayTag = '[object Array]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeIsArray = getNative(Array, 'isArray');\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(function() { return arguments; }());\n * // => false\n */\nvar isArray = nativeIsArray || function(value) {\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n};\n\nmodule.exports = isArray;\n","var isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in older versions of Chrome and Safari which return 'function' for regexes\n  // and Safari 8 which returns 'object' for typed array constructors.\n  return isObject(value) && objToString.call(value) == funcTag;\n}\n\nmodule.exports = isFunction;\n","var isFunction = require('./isFunction'),\n    isObjectLike = require('../internal/isObjectLike');\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (isFunction(value)) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = isNative;\n","/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var getNative = require('../internal/getNative'),\n    isArrayLike = require('../internal/isArrayLike'),\n    isObject = require('../lang/isObject'),\n    shimKeys = require('../internal/shimKeys');\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = getNative(Object, 'keys');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nvar keys = !nativeKeys ? shimKeys : function(object) {\n  var Ctor = object == null ? undefined : object.constructor;\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n      (typeof object != 'function' && isArrayLike(object))) {\n    return shimKeys(object);\n  }\n  return isObject(object) ? nativeKeys(object) : [];\n};\n\nmodule.exports = keys;\n","var isArguments = require('../lang/isArguments'),\n    isArray = require('../lang/isArray'),\n    isIndex = require('../internal/isIndex'),\n    isLength = require('../internal/isLength'),\n    isObject = require('../lang/isObject');\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  if (object == null) {\n    return [];\n  }\n  if (!isObject(object)) {\n    object = Object(object);\n  }\n  var length = object.length;\n  length = (length && isLength(length) &&\n    (isArray(object) || isArguments(object)) && length) || 0;\n\n  var Ctor = object.constructor,\n      index = -1,\n      isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n      result = Array(length),\n      skipIndexes = length > 0;\n\n  while (++index < length) {\n    result[index] = (index + '');\n  }\n  for (var key in object) {\n    if (!(skipIndexes && isIndex(key, length)) &&\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = keysIn;\n","/**\n * This method returns the first argument provided to it.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'user': 'fred' };\n *\n * _.identity(object) === object;\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","\nvar rng;\n\nif (global.crypto && crypto.getRandomValues) {\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // Moderately fast, high quality\n  var _rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(_rnds8);\n    return _rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  _rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return _rnds;\n  };\n}\n\nmodule.exports = rng;\n\n","//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = require('./rng');\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\n// **`parse()` - Parse a UUID into it's component bytes**\nfunction parse(s, buf, offset) {\n  var i = (buf && offset) || 0, ii = 0;\n\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n    if (ii < 16) { // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\n// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\nfunction unparse(buf, offset) {\n  var i = offset || 0, bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; n++) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : unparse(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ii++) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || unparse(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nuuid.parse = parse;\nuuid.unparse = unparse;\n\nmodule.exports = uuid;\n"],"sourceRoot":"/source/"}